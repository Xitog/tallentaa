<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Test</title>
    <style type="text/css">
      canvas { 
        border: 1px solid black;
      }
      html {
        width: 100%;
        height: 100%;
        background: rgb(10, 10, 10);
        overflow:hidden;
      }
      body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      img.shadow {
        display: none;
      }
    </style>
  </head>
  <body onload="start();">
    <canvas id="screen" width="640" height="480">Your browser must support canvas to play.</canvas>
    <!-- Water to Earth transitions W E | N E S W -->
      <!-- One Border -->
      <img class="shadow" id="0100010000" src="graphics/textures/0100010000.bmp">
      <img class="shadow" id="0100100000" src="graphics/textures/0100100000.bmp">
      <img class="shadow" id="0101000000" src="graphics/textures/0101000000.bmp">
      <img class="shadow" id="0110000000" src="graphics/textures/0110000000.bmp">
      <!-- Two Borders -->
      <img class="shadow" id="0111000000" src="graphics/textures/0111000000.bmp">
      <img class="shadow" id="0101100000" src="graphics/textures/0101100000.bmp">
      <img class="shadow" id="0100110000" src="graphics/textures/0100110000.bmp">
      <img class="shadow" id="0110010000" src="graphics/textures/0110010000.bmp">
      <!-- Corners -->
      <img class="shadow" id="0100001000" src="graphics/textures/0100001000.bmp">
      <img class="shadow" id="0100000100" src="graphics/textures/0100000100.bmp">
      <img class="shadow" id="0100000010" src="graphics/textures/0100000010.bmp">
      <img class="shadow" id="0100000001" src="graphics/textures/0100000001.bmp">
      <!-- 2 Corners -->
      <img class="shadow" id="0100001010" src="graphics/textures/0100001010.bmp">
      <img class="shadow" id="0100000101" src="graphics/textures/0100000101.bmp">
    <!-- Earth to Grass transitions W E | N E S W -->
      <!-- One Border -->
      <img class="shadow" id="1200010000" src="graphics/textures/1200010000.bmp">
      <img class="shadow" id="1200100000" src="graphics/textures/1200100000.bmp">
      <img class="shadow" id="1201000000" src="graphics/textures/1201000000.bmp">
      <img class="shadow" id="1210000000" src="graphics/textures/1210000000.bmp">
      <!-- Two Borders -->
      <img class="shadow" id="1211000000" src="graphics/textures/1211000000.bmp">
      <img class="shadow" id="1201100000" src="graphics/textures/1201100000.bmp">
      <img class="shadow" id="1200110000" src="graphics/textures/1200110000.bmp">
      <img class="shadow" id="1210010000" src="graphics/textures/1210010000.bmp">
      <!-- Corners -->
      <img class="shadow" id="1200001000" src="graphics/textures/1200001000.bmp">
      <img class="shadow" id="1200000100" src="graphics/textures/1200000100.bmp">
      <img class="shadow" id="1200000010" src="graphics/textures/1200000010.bmp">
      <img class="shadow" id="1200000001" src="graphics/textures/1200000001.bmp">
      <!-- 2 Corners -->
      <img class="shadow" id="1200001010" src="graphics/textures/1200001010.bmp">
      <img class="shadow" id="1200000101" src="graphics/textures/1200000101.bmp">
    <!-- Basic textures -->
    <img class="shadow" id="0000000000" src="graphics/textures/0000000000.bmp">
    <img class="shadow" id="1000000000" src="graphics/textures/1000000000.bmp">
    <img class="shadow" id="2000000000" src="graphics/textures/2000000000.bmp">
    <img class="shadow" id="3000000000" src="graphics/textures/3000000000.bmp">
    <script type="text/javascript">
      // Core functions
      //     start -> load, run
      //     run   -> update, draw
      // Input functions
      //     on_mouse_move
      //     on_mouse_right_click
      //     on_key_down
      //     on_mouse_left_click
      
      'use strict';
      
      const SCREEN_WIDTH = 640;
      const SCREEN_HEIGHT = 480;
      
      const CAM_MAX_COL = 20; // = 640 / 32
      const CAM_MAX_ROW = 15; // = 480 / 32
      const SCROLLING_ZONE = 10;
      
      const MAP_MAX_COL = 32;
      const MAP_MAX_ROW = 32;
      
      class Map {
        constructor(name, content) {
          this.name = name;
          this.content = content;
        }
      }
      
      const ARCHIPELAGO = new Map("Archipelago", [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 00
        [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 01
        [0, 0, 1, 1, 1, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 02
        [0, 0, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], // 03
        [0, 0, 1, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0], // 04
        [0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0], // 05
        [0, 1, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 1, 0, 0], // 06
        [0, 0, 1, 1, 1, 2, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0], // 07
        [0, 0, 0, 0, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0], // 08
        [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 2, 1, 0, 0, 0, 0], // 09
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], // 10
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], // 11
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], // 12
        [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0], // 13 
        [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 0], // 14
        [0, 0, 0, 1, 1, 1, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0], // 15
        [0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0], // 16
        [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0], // 17
        [0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], // 18
        [0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], // 19
        [0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], // 20
        [0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], // 21
        [0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 0], // 22
        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 0, 0], // 23
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 1, 0, 0], // 24
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 1, 0], // 25
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 1, 1, 1, 0], // 26
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 1, 1, 1, 0, 0, 0], // 27
        [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0], // 28
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], // 29
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], // 30
        [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 31
      ]);
      
      //-----------------------------------------------------------------------
      // Core : Data model
      //-----------------------------------------------------------------------
      
      class Order {
        constructor(type, row, col) {
          this.type = type;
          this.row = row;
          this.col = col;
        }
      }
      
      var IDUnit = 0;
      
      class Unit {
        
        constructor(player, type, row, col) {
          this.player = player;
          console.log('creating unit', IDUnit, 'at', row, col);
          this.type = type;
          this.row = row;
          this.col = col;
          this.selected = false;
          this.life = 100;
          this.orders = [];
          this.id = IDUnit;
          IDUnit += 1;
          if (this.type == 'soldier') {
            this.speed = 3;
          } else {
            throw "Unknown type for Unit";
          }
          this.speed_counter = this.speed;
        }
        
        order(o, add) {
          if (!add) {
            this.orders.length = 0;
          }
          this.orders.push(o);
        }
        
        move(o) {
          let new_row = this.row;
          let new_col = this.col;
          console.log('I am unit', this.id, 'and I am moving');
          if (o.row > this.row) {
            new_row += 1;
          } else if (o.row < this.row) {
            new_row -= 1;
          }
          if (o.col > this.col) {
            new_col += 1;
          } else if (o.col < this.col) {
            new_col -= 1;
          }
          if (game.units[new_row][new_col] != 0 || !pass_matrix[new_row][new_col]) {
            if (game.units[new_row][this.col] == 0 && pass_matrix[new_row][this.col]) {
              new_col = this.col;
            } else if (game.units[this.row][new_col] == 0 && pass_matrix[this.row][new_col]) {
              new_row = this.row;
            }
          }
          if (game.units[new_row][new_col] == 0 && pass_matrix[new_row][new_col]) {
            console.log('cleaning', this.row, this.col);
            game.units[this.row][this.col] = 0;
            this.row = new_row;
            this.col = new_col;
            game.units[this.row][this.col] = this;
            console.log('setting', this.id, 'at', this.row, this.col);
            if (o.row == this.row && o.col == this.col) {
              this.orders.shift();
            }
            this.speed_counter = this.speed;
          }
        }
        
        update() {
          if (this.speed_counter == 0 && this.orders.length > 0) {
            let o = this.orders[0];
            if (o.type == 'move') {
              this.move(o);
            }
          } else if (this.speed_counter > 0) {
            this.speed_counter -= 1;
          }
          //console.log(this.life);
        }
      }
      //const u = new Unit(5, 5);
      
      /*class Position {
        constructor(row, col) {
          this.row = row;
          this.col = col;
        }
      }*/
      
      class Player {
        constructor(name, color, row, col) {
          this.name = name;
          this.color = color;
          this.row = row;
          this.col = col;
        }
      }
      
      class Game {
        constructor(name) {
          this.name = name;
          this.players = {};
          this.units = [];
          this.all_units = [];
          this.map = ARCHIPELAGO.content;
          for (let row = 0; row < MAP_MAX_ROW; row++) {
            this.units[row] = [];
            for (let col=0; col < MAP_MAX_COL; col++) {
              this.units[row][col] = 0;
            }
          }
        }
        
        create_player(name, color, row, col) {
          let p = new Player(name, color, row, col);
          this.players[name] = p;
        }
        
        create_unit(player, type, row, col) {
          player = this.players[player];
          let u = new Unit(player, type, row, col);
          this.units[row][col] = u;
          this.all_units.push(u);
        }
      }
      
      const game = new Game("A lost cause");
      
      game.create_player('Sarah', 'rgb(0, 128, 255)', 0, 0);
      game.create_player('Tom', 'rgb(255, 127, 39)', 2, 2);
      game.create_unit('Sarah', 'soldier', 5, 5);
      game.create_unit('Sarah', 'soldier', 5, 6);
      game.create_unit('Tom', 'soldier', 10, 6);
      
      //-----------------------------------------------------------------------
      // Graphisme
      //-----------------------------------------------------------------------
      
      var textures = {};
      
      var screen = null;
      
      var mouse_map_col = -1;
      var mouse_map_row = -1;
      var mouse_col = -1;
      var mouse_row = -1;
      
      var scroll_left = false;
      var scroll_right = false;
      var scroll_up = false;
      var scroll_down = false;
      
      //-----------------------------------------------------------------------
      // Core functions : load, start, run, update, draw
      //-----------------------------------------------------------------------
      
      function load() {
        for (let o of document.images) {
          textures[o.id] = o;
        }
      }
      
      function start() {
        screen = document.getElementById('screen');
        screen.onmousemove = on_mouse_move;
        window.onclick = on_mouse_left_click;
        window.oncontextmenu = on_mouse_right_click;
        window.onkeydown = on_key_down;
        window.onkeyup = on_key_up;
        window.setInterval(run, 33);
        load();
        run();
      }
      
      function run() {
        update();
        draw();
      }
      
      function update() {
        for (let u of game.all_units) {
          u.update();
        }
        let old_cam_col = camera.col;
        let old_cam_row = camera.row;
        if (scroll_right) {
          camera.col = (camera.col > 0 ? camera.col - 1 : 0);
        } else if (scroll_left) {
          camera.col = (camera.col < (MAP_MAX_COL - CAM_MAX_COL) ? camera.col + 1 : camera.col);
        } else if (scroll_up) {
          camera.row = (camera.row > 0 ? camera.row - 1 : 0);
        } else if (scroll_down) {
          camera.row = (camera.row < (MAP_MAX_ROW - CAM_MAX_ROW) ? camera.row + 1 : camera.row);
        }
        // update mouse coordinates on the map!
        if (old_cam_col != camera.col || old_cam_row != camera.row) {
          if (camera.col < old_cam_col) {
            mouse_map_col -= 1;
          } else if (camera.col > old_cam_col) {
            mouse_map_col += 1;
          }
          if (camera.row < old_cam_row) {
            mouse_map_row -= 1;
          } else if (camera.row > old_cam_row) {
            mouse_map_row += 1;
          }
        }
      }
      
      class Minimap {
        constructor(x, y) {
          this.show = true;
          this.size = 3;
          this.x = x;
          this.y = y;
          this.max_x = this.x + this.size * 32;
          this.max_y = this.y + this.size * 32;
        }
        
        draw(ctx) {
          let row = 0;
          let col = 0;
          for (let x = this.x; x < this.max_x; x += this.size) {
            for (let y = this.y; y < this.max_y; y += this.size) {
              let val = game.map[row][col][0];
              if (game.units[row][col] != 0) {
                if (game.units[row][col].player == camera.player) {
                  val = 'unit';
                } else {
                  val = 'enemy';
                }
              }
              switch (val) {
                case 'unit':
                  ctx.fillStyle = 'rgb(0, 255, 0)';
                  ctx.fillRect(x, y, this.size, this.size);
                  break;
                case 'enemy':
                  ctx.fillStyle = 'rgb(255, 0, 0)';
                  ctx.fillRect(x, y, this.size, this.size);
                  break;
                case '0':
                  ctx.fillStyle = 'rgb(49, 86, 98)';
                  ctx.fillRect(x, y, this.size, this.size);
                  break;
                case '1':
                  ctx.fillStyle = 'rgb(126, 82, 18)';
                  ctx.fillRect(x, y, this.size, this.size);
                  break;
                case '2':
                  ctx.fillStyle = 'rgb(41, 102, 0)';
                  ctx.fillRect(x, y, this.size, this.size);
                  break;
                default:
                  throw "Center not defined";
              }
              row += 1;
            }
            col += 1;
            row = 0;
          }
          ctx.strokeStyle = 'rgb(255, 242, 0)';
          ctx.rect(this.x, this.y, this.size*32, this.size*32);
          ctx.stroke();
        }
      }
      
      class Camera {
        constructor(player) {
          this.player = player;
          this.minimap = new Minimap(SCREEN_WIDTH - 3 * 32, SCREEN_HEIGHT - 3 * 32);
          this.row = player.row;
          this.col = player.col;
        }
      }
      var camera = new Camera(game.players['Sarah']);
      
      function draw_unit(ctx, u) {
        let posx = (u.col - camera.col) * 32 + 16;
        let posy = (u.row - camera.row) * 32 + 16;
        // Unit
        ctx.fillStyle = u.player.color;
        ctx.beginPath();
        ctx.arc(posx, posy, 10, 0, 2 * Math.PI);
        ctx.fill();
        // Circle of selection
        if (u.selected) {
          if (u.player == camera.player) {
            ctx.strokeStyle = 'rgb(0, 255, 0)';
          } else {
            ctx.strokeStyle = 'rgb(255, 0, 0)';
          }
          ctx.beginPath();
          ctx.arc(posx, posy, 15, 0, 2 * Math.PI);
          ctx.stroke();
        }
      }
      
      function draw() {
        if (screen.getContext) {
          let ctx = screen.getContext('2d');
          for (let row = 0; row < CAM_MAX_ROW; row++) {
            for (let col = 0; col < CAM_MAX_COL; col++) {
              let r = row + camera.row;
              let c = col + camera.col;
              let img = game.map[r][c];
              try {
                ctx.drawImage(textures[img], col * 32, row * 32);
              } catch (e) {
                console.log("Image=", img, "Type=", typeof(img), "Exception=", e);
                throw "End";
              }
              let u = game.units[r][c];
              if (u != 0) {
                draw_unit(ctx, u, r, c);
              }
            }
          }
          // orders
          for (let u of selected) {
            if (u.orders.length > 0) {
              let start_col = (u.col - camera.col) * 32 + 16;
              let start_row = (u.row - camera.row) * 32 + 16;
              let next_col = start_col;
              let next_row = start_row;
              for (let o of u.orders) {
                if (o.type == 'move') {
                  // Line
                  ctx.strokeStyle = 'rgb(255, 0, 0)';
                  ctx.beginPath();
                  ctx.moveTo(next_col, next_row);
                  ctx.lineTo((o.col - camera.col) * 32 + 16, (o.row - camera.row) * 32 + 16);
                  ctx.stroke();
                  // Target
                  ctx.fillStyle = 'rgb(255, 0, 0)';
                  ctx.beginPath();
                  ctx.arc((o.col - camera.col) * 32 + 16, (o.row - camera.row) * 32 + 16, 5, 0, 2 * Math.PI);
                  ctx.fill();
                  // Chain
                  next_col = (o.col - camera.col) * 32 + 16;
                  next_row = (o.row - camera.row) * 32 + 16;
                }
              }
              draw_unit(ctx, u);
              // Redraw unit because of the line
              //if (u.selected) {
              //  ctx.fillStyle = 'rgb(0, 255, 0)';
              //} else { 
              //  ctx.fillStyle = 'rgb(255, 0, 0)';
              //}
              //ctx.beginPath();
              //ctx.arc(start_col, start_row, 10, 0, 2 * Math.PI);
              //ctx.fill();
            }
          }
          // Minimap
          if (camera.minimap.show) {
            camera.minimap.draw(ctx);
          }
          //ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
          //ctx.fillRect(64, 64, 32, 32);
          // Mouse
          if (mouse_map_col != -1 || mouse_map_row != -1) {
            ctx.strokeStyle = 'rgb(0, 255, 0)';
            ctx.strokeRect(Math.floor(mouse_col / 32) * 32, Math.floor(mouse_row / 32) * 32, 32, 32);
          }
        } else {
          alert("Your browser must support canvas to play.");
        }
      }
      
      //-----------------------------------------------------------------------
      // UI : Input handling
      //-----------------------------------------------------------------------
      
      // Consts
      
      const KEY_UP = 38;
      const KEY_DOWN = 40;
      const KEY_RIGHT = 39;
      const KEY_LEFT = 37;
      const KEY_BACKSPACE = 8;
      const KEY_M = 77;
      
      // Functions
      
      function on_mouse_move(event) {
        event = event || window.event;
        // Mouse coordinates
        let screenRect = screen.getBoundingClientRect();
        mouse_col = event.pageX - screenRect.left;
        mouse_row = event.pageY - screenRect.top;
        mouse_map_col = Math.floor(mouse_col / 32) + camera.col;
        mouse_map_row = Math.floor(mouse_row / 32) + camera.row;
        // Scrolling
        scroll_left = false;
        scroll_right = false;
        scroll_up = false;
        scroll_down = false;
        if (mouse_col < SCROLLING_ZONE) {
          scroll_right = true;
        } else if (mouse_col > SCREEN_WIDTH - SCROLLING_ZONE) {
          scroll_left = true;
        }
        if (mouse_row < SCROLLING_ZONE) {
          scroll_up = true;
        } else if (mouse_row > SCREEN_HEIGHT - SCROLLING_ZONE) {
          scroll_down = true;
        }
      }
      
      var clicked = false;
      var iTimer;
      
      var selected = [];
      var prev_selected = null;
      
      function unselect() {
        for (let o of selected) {
          console.log('unselecting unit:', o.id);
          o.selected = false;
        }
        selected.length = 0;
      }
      
      function select(u) {
        u.selected = true;
        selected.push(u);
      }
      
      function save_selection() {
        prev_selected = Array.from(selected);
      }
      
      function restore_selection() {
        console.log(prev_selected);
        if (prev_selected) {
          unselect();
          for (let u of prev_selected) {
            select(u);
          }
        }
      }
      
      function on_mouse_left_click(event) {
        if (event.button == 0) {
          if (event.ctrlKey) {
            console.log('Ctrl + Left Click');
          } else {
            console.log('Left Click');
          }
          console.log('row', mouse_map_row, 'col', mouse_map_col,);
          // unselected current group (do that only if there is an unit to hold the selection)
          if (!event.ctrlKey) {
            save_selection();
            unselect();
          }
          // select
          let u = game.units[mouse_map_row][mouse_map_col];
          if (u != 0) {
            if (!event.ctrlKey || (event.ctrlKey && u.player == camera.player)) { // with ctrl you can only add your unit
              console.log('selecting unit:', u.id);
              select(u);
            }
          }
        }
        /*
        if (!clicked) {
          console.log('Left Click');
          clicked = true;
          iTimer = setTimeout(function() { clicked = false; }, 250);
        } else if (iTimer < 10) {
          console.log('Double Click');
          clicked = false;
          clearTimeout(iTimer);
        }
        */
      }
      
      function on_mouse_right_click(event) {
        event = window.event || event;
        console.log("Right click");
        for (let u of selected) {
          if (u.player == camera.player) {
            console.log("Sending order move to unit", u.id, 'to', 'row', mouse_map_row, 'col', mouse_map_col);
            u.order(new Order('move', mouse_map_row, mouse_map_col), event.ctrlKey);
          }
        }
        return false;     // prevent default menu
      }
      
      function on_key_up(event) {
        event = window.event || event;
        if (event.keyCode == KEY_UP) {
          scroll_up = false;
        } else if (event.keyCode == KEY_DOWN) {
          scroll_down = false;
        } else if (event.keyCode == KEY_RIGHT) {
          scroll_left = false;
        } else if (event.keyCode == KEY_LEFT) {
          scroll_right = false;
        } else if (event.keyCode == KEY_BACKSPACE) {
          restore_selection();
        } else if (event.keyCode == KEY_M) {
          camera.minimap.show = !camera.minimap.show;
        } else {
          console.log('Unbound up key:', event.keyCode);
        }
      }
      
      function on_key_down(event){
        event = window.event || event;
        if (event.keyCode == KEY_UP) {
          scroll_up = true;
        } else if (event.keyCode == KEY_DOWN) {
          scroll_down = true;
        } else if (event.keyCode == KEY_RIGHT) {
          scroll_left = true;
        } else if (event.keyCode == KEY_LEFT) {
          scroll_right = true;
        } else {
          console.log('Unbound down key:', event.keyCode);
        }
        //return false; // prevent default
      }
      
      //-----------------------------------------------------------------------
      // Transition system
      //-----------------------------------------------------------------------
      
      var modified = {
        "0" : [1],
        "1" : [2],
        "2" : [],
        "3" : [],
      };
      
      var trans_matrix = [];
      var pass_matrix = [];
      
      function transition_one(trow, tcol) {
        let calc = 0;
        let pow = 8;
        let center = game.map[trow][tcol];
        let opposed = null;
        outerloop:
        for (let row = trow - 1; row <= trow + 1; row++) {
          for (let col = tcol - 1; col <= tcol + 1; col++) {
            if (row != trow || col != tcol) {
              if (row >= 0 && row < MAP_MAX_ROW && col >= 0 && col < MAP_MAX_COL) {
                // Get opposed
                if (game.map[row][col] != center) {
                  // Check IF opposed is NOT defined AND if the other texture encountered modifies the center
                  if (!opposed && modified[center].includes(game.map[row][col])) {
                    opposed = game.map[row][col];
                  // Check IF opposed is defined AND if the other texture is different from the opposed
                  } else if (opposed && opposed != game.map[row][col] && modified[center].includes(game.map[row][col])) {
                    console.log("Surrounded by two different textures, aborting at ", row, col, "opp=", opposed, "found=", game.map[row][col], "me=", center);
                    break outerloop;
                  }
                }
                // Calculate transition
                if (game.map[row][col] == opposed) {
                  calc += 1 * Math.pow(2, pow);
                }
              }
              pow -= 1;
            }
          }
        }
        let cal = [center, 0, 
                   0, 0, 0, 0,
                   0, 0, 0, 0];
        let O = 1;
        let N = 2 + 0;
        let E = 2 + 1;
        let S = 2 + 2;
        let W = 2 + 3;
        let NW = 6 + 0;
        let NE = 6 + 1;
        let SE = 6 + 2;
        let SW = 6 + 3;
        if ([0, 1].includes(center)) {
          opposed = modified[center]; // Earth
          // Borders
          if (trow > 0 && game.map[trow - 1][tcol] == opposed) { cal[O] = opposed; cal[N] = 1; }
          if (tcol > 0 && game.map[trow][tcol - 1] == opposed) { cal[O] = opposed; cal[W] = 1; }
          if (trow < MAP_MAX_ROW - 2 && game.map[trow + 1][tcol] == opposed) { cal[O] = opposed; cal[S] = 1; }
          if (tcol < MAP_MAX_COL - 2 && game.map[trow][tcol + 1] == opposed) { cal[O] = opposed; cal[E] = 1; }
          // Corners only if no borders
          if (cal[N] == 0 && cal[E] == 0 && cal[S] == 0 && cal[W] == 0) {
            if (trow > 0 && tcol > 0 && game.map[trow - 1][tcol - 1] == opposed) { cal[O] = opposed; cal[NW] = 1; }
            if (trow > 0 && tcol < MAP_MAX_COL - 2 && game.map[trow - 1][tcol + 1] == opposed) { cal[O] = opposed; cal[NE] = 1; }
            if (trow < MAP_MAX_ROW - 2 && tcol < MAP_MAX_COL - 2 && game.map[trow + 1][tcol + 1] == opposed) { cal[O] = opposed; cal[SE] = 1; }
            if (trow < MAP_MAX_ROW - 2 && tcol > 0 && game.map[trow + 1][tcol - 1] == opposed) { cal[O] = opposed; cal[SW] = 1; }
          }
        }
        trans_matrix[trow][tcol] = cal.join('');
        if (center > 0) {
          pass_matrix[trow][tcol] = true;
        }
        /*
        var EAST = 0b0010;
        if (calc & EAST) {
          trans_matrix[trow][tcol] = 82;
        //if (calc == 82 || calc == 86 || calc == 2) {
        //  trans_matrix[trow][tcol] = calc;
        } else {
          
        }
        console.log('row=', trow, 'col=', tcol, 'center=', map[trow][tcol], 'calculated=', calc);
        //console.log(pow);
        */
      }
      
      function make_transition() {
        // Prepare trans_matrix
        for (let row = 0; row < MAP_MAX_ROW; row++) {
          trans_matrix[row] = [];
          pass_matrix[row] = [];
          for (let col=0; col < MAP_MAX_COL; col++) {
            trans_matrix[row][col] = '3000000000';
            pass_matrix[row][col] = false;
          }
        }
        // Do transitions
        for (let row=0; row < MAP_MAX_ROW; row++) {
          for (let col=0; col < MAP_MAX_COL; col++) {
            transition_one(row, col);
          }
        }
        // Swap
        game.map = trans_matrix;
      }
      make_transition();
    
    </script>
  </body>
</html>