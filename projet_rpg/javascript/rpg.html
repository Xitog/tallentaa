<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Test</title>
    <style type="text/css">
      canvas { 
        border: 1px solid black;
      }
      html {
        width: 100%;
        height: 100%;
        background: rgb(10, 10, 10);
        overflow:hidden;
      }
      body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      img.shadow {
        display: none;
      }
    </style>
  </head>
  <body onload="start();">
    <canvas id="screen" width="960" height="800">Your browser must support canvas to play.</canvas>
    <img class="shadow" id="grey" src="graphics/grey.png">
    <!--<img class="shadow" id="black" src="graphics/black.png">-->
    <img class="shadow" id="brown" src="graphics/brown.png">
    <img class="shadow" id="darkblue" src="graphics/darkblue.png">
    <img class="shadow" id="blue" src="graphics/blue.png">
    <img class="shadow" id="green" src="graphics/green.png">
    <img class="shadow" id="grey" src="graphics/grey.png">
    <img class="shadow" id="lemongreen" src="graphics/lemongreen.png">
    <img class="shadow" id="lightpurple" src="graphics/lightpurple.png">
    <img class="shadow" id="orange" src="graphics/orange.png">
    <img class="shadow" id="pink" src="graphics/pink.png">
    <img class="shadow" id="purple" src="graphics/purple.png">
    <img class="shadow" id="red" src="graphics/red.png">
    <img class="shadow" id="skyblue" src="graphics/skyblue.png">
    <img class="shadow" id="steelblue" src="graphics/steelblue.png">
    <img class="shadow" id="yellow" src="graphics/yellow.png">
    <img class="shadow" id="lobster" src="graphics/lobster.png">
    
    <script type="text/javascript">
    
      // 20 => 640 25 => 800 30 => 960
      const SCREEN_WIDTH = 960;
      const SCREEN_HEIGHT = 800;
      
      const CAM_MAX_COL = SCREEN_WIDTH / 32; // 30
      const CAM_MAX_ROW = SCREEN_HEIGHT / 32; // 25
      
      var screen = null;
      var mouse_col = -1;
      var mouse_row = -1;
      
      const KEY_UP = 38;
      const KEY_DOWN = 40;
      const KEY_RIGHT = 39;
      const KEY_LEFT = 37;
      const KEY_BACKSPACE = 8;
      const KEY_M = 77;
      
      const NONE = 0;
      const VERTICAL = 1;
      const HORIZONTAL = 2;
      const MIN_DIV = 3;
      const MAX_DIVISION = 4;
      
      var map = [];
      var textures = [];
      var color_index = 5;
      
      function get_color() {
        let res = color_index;
        color_index += 1;
        if (color_index == textures.length) {
          color_index = 0;
        }
        console.log("color = " + res + " / " + textures.length);
        return res;
      }
      
      // 2 essais : Lua (1er) Python (2e)
      class Room {
        constructor(map, parent, x, y, width, height) { //, div_type, div_pos, hole, parent) {
          this.map = map;
          this.x = x;
          this.y = y;
          this.w = width; // col max
          this.h = height; // row max
          this.color = get_color();
          //this.hole = NONE;
          this.parent = parent;
          if (this.parent == null) {
            this.level = 0;
          } else {
            this.level = this.parent.level + 1;
          }
          this.div = 0;
          this.top = null;
          this.bottom = null;
          this.left = null;
          this.right = null;
          console.log("  ".repeat(this.level) + "Creating room x=" + x + " y=" + y + " width/colmax=" + width + " height/rowmax=" + height + " on map col=" + map[0].length + " row=" + map.length);
        }
        
        has_child() {
          return (this.div != 0);
          //return (!(this.top == null && this.bottom == null && this.left == null && this.right == null));
        }
        
        first() {
          if (this.top != null) {
            return (this.top);
          } else if (this.left != null) {
            return (this.left);
          } else {
            throw "No first child.";
          }
        }
        
        second() {
          if (this.bottom != null) {
            return (this.bottom);
          } else if (this.right != null) {
            return (this.right);
          } else {
            throw "No second child.";
          }
        }
        
        divide(times) {
          if (this.has_child()) {
            throw "Can divide this room, already divided";
          }
          let length = 0;
          let intent = NONE;
          if (this.w > this.h) {
            length = this.w;
            intent = VERTICAL;
          } else {
            length = this.h;
            intent = HORIZONTAL;
          }
          if (length > MIN_DIV * 2 + 1) {
            if (length & 1) { // odd
              // 0 1 2 3 4 5 6 7 8 => 9
              // length / 2 = 4, possible = 3, 4, 5 soit -1, 0, 1
              this.div = getRandomIntInclusive(1, 3) - 2 + Math.floor(length / 2);
            } else { // even
              // 0 1 2 3 4 5 6 7 8 9 => 10
              // length / 2 = 5, possible = 3, 4, 5, 6 soit -2 -1 0 1
              this.div = getRandomIntInclusive(1, 4) - 3 + length / 2;
            }
            // Create the two children
            if (intent == VERTICAL) {
              this.left = new Room(map, this, this.x, this.y, this.div, this.h);
              this.right = new Room(map, this, this.x + this.div, this.y, this.w - this.div, this.h);
            } else {
              this.top = new Room(map, this, this.x, this.y, this.w, this.div);
              this.bottom = new Room(map, this, this.x, this.y + this.div, this.w, this.h - this.div);
            }
            // Divide
            if (times - 1 > 0) {
              this.first().divide(times - 1);
              this.second().divide(times - 1);
            }
          }
        }
        
        draw() {
          if (this.has_child()) {
            this.first().draw();
            this.second().draw();
          } else {
            for (let row = this.y; row < this.y + this.h; row++) {
              for (let col = this.x; col < this.x + this.w; col++) {
                if (row >= this.map.length || col >= this.map[0].length) {
                  throw "Map is too small for this room: row=" + row + " col=" + col + "/" + this.w;
                }
                this.map[row][col] = this.color;
              }
            }
          }
        }
        
      }
      
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      function make_dungeon(map) {
        for (let row = 0; row < CAM_MAX_ROW; row++) {
          map.push([])
          for (let col = 0; col < CAM_MAX_COL; col++) {
            map[row].push(0);
          }
        }
        let room = new Room(map, null, 0, 0, CAM_MAX_COL, CAM_MAX_ROW); // x y width height
        room.divide(MAX_DIVISION);
        room.draw();
        console.log(map);
        return room;
      }
      
      function load() {
        for (let o of document.images) {
          textures.push(o);
          //textures[o.id] = o;
        }
        console.log("End loading " + textures.length + " textures.");
      }
      
      function start() {
        screen = document.getElementById('screen');
        screen.onmousemove = on_mouse_move;
        window.onclick = on_mouse_left_click;
        window.oncontextmenu = on_mouse_right_click;
        window.onkeydown = on_key_down;
        window.onkeyup = on_key_up;
        window.setInterval(run, 33);
        load();
        let root = make_dungeon(map);
        run();
      }
      
      function run() {
        update();
        draw();
      }
      
      function update() {
      }
      
      function draw() {
        if (screen.getContext) {
          let ctx = screen.getContext('2d');
          for (let row = 0; row < CAM_MAX_ROW; row++) {
            for (let col = 0; col < CAM_MAX_COL; col++) {
              let val = map[row][col];
              ctx.drawImage(textures[val], col * 32, row * 32);
            }
          }
          
          ctx.strokeStyle = 'rgb(0, 255, 0)';
          ctx.strokeRect(Math.floor(mouse_col / 32) * 32, Math.floor(mouse_row / 32) * 32, 32, 32);
            
          //ctx.fillStyle = 'rgb(255, 0, 0)';
          //ctx.fillRect(x, y, this.size, this.size);
          
          //ctx.strokeStyle = 'rgb(255, 242, 0)';
          //ctx.beginPath();
          //ctx.rect(this.x, this.y, this.size*32, this.size*32);
          //ctx.stroke();
          
          //ctx.beginPath();
          //ctx.arc(posx, posy, 10, 0, 2 * Math.PI);
          //ctx.fill();
        }
      }
      
      function on_mouse_move(event) {
        event = event || window.event;
        // Mouse coordinates
        let screenRect = screen.getBoundingClientRect();
        mouse_col = event.pageX - screenRect.left;
        mouse_row = event.pageY - screenRect.top;
        //mouse_map_col = Math.floor(mouse_col / 32) + camera.col;
        //mouse_map_row = Math.floor(mouse_row / 32) + camera.row;
      }
      
      function on_mouse_left_click(event) {
        event = event || window.event;
        console.log('Mouse col:', Math.floor(mouse_col / 32), 'Mouse row:', Math.floor(mouse_row / 32));
      }
      
      function on_mouse_right_click(event) {
        event = event || window.event;
        console.log('Mouse col:', mouse_col, 'Mouse row:', mouse_row);
        return false;     // prevent default menu
      }
      
      function on_key_up(event) {
        event = window.event || event;
        if (event.keyCode == KEY_UP) {
          //...
        } else {
          console.log('Unbound up key:', event.keyCode);
        }
      }
      
      function on_key_down(event){
        event = window.event || event;
        if (event.keyCode == KEY_LEFT) {
          //...
        } else {
          console.log('Unbound down key:', event.keyCode);
        }
      }
      
    </script>
  </body>
</html>