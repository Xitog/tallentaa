<!DOCTYPE html>
<html lang="en">
  <!---------------------------------------------------------------------------
    BSP Dungeons in JavaScript + HTML + CSS
    Inspired by http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation
    First version in Lua/LÃ¶ve February/March 2017
    This version is the second or the third.
    1) Making a tree of spaces with divide()
    2) Digging the rooms inside the spaces with dig()
    3) Connecting with spade() the rooms
    4) Drawing the dungeon (populate the matrix)
    Search TODO for the next thing to do.
    Author: Damien Gouteux
    -------------------------------------------------------------------------->
  <head>
    <meta charset="utf-8"/>
    <title>Test</title>
    <style type="text/css">
      canvas {
        border: 1px solid black;
      }
      html {
        width: 100%;
        height: 100%;
        background: rgb(10, 10, 10);
        overflow:hidden;
      }
      body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      img.shadow {
        display: none;
      }
    </style>
  </head>
  <body onload="start();">
    <canvas id="screen" width="960" height="800">Your browser must support canvas to play.</canvas>
    <img class="shadow" id="black" src="graphics/black.png">
    <img class="shadow" id="grey" src="graphics/grey.png">
    <img class="shadow" id="brown" src="graphics/brown.png">
    <img class="shadow" id="darkblue" src="graphics/darkblue.png">
    <img class="shadow" id="blue" src="graphics/blue.png">
    <img class="shadow" id="green" src="graphics/green.png">
    <img class="shadow" id="lemongreen" src="graphics/lemongreen.png">
    <img class="shadow" id="lightpurple" src="graphics/lightpurple.png">
    <img class="shadow" id="orange" src="graphics/orange.png">
    <img class="shadow" id="pink" src="graphics/pink.png">
    <img class="shadow" id="purple" src="graphics/purple.png">
    <img class="shadow" id="red" src="graphics/red.png">
    <img class="shadow" id="skyblue" src="graphics/skyblue.png">
    <img class="shadow" id="steelblue" src="graphics/steelblue.png">
    <img class="shadow" id="yellow" src="graphics/yellow.png">
    <img class="shadow" id="lobster" src="graphics/lobster.png">
    
    <script type="text/javascript">

      // 20 => 640 25 => 800 30 => 960
      const SCREEN_WIDTH = 960;
      const SCREEN_HEIGHT = 800;
      
      const CAM_MAX_COL = SCREEN_WIDTH / 32; // 30
      const CAM_MAX_ROW = SCREEN_HEIGHT / 32; // 25
      
      var screen = null;
      var mouse_col = -1;
      var mouse_row = -1;
      
      const KEY_UP = 38;
      const KEY_DOWN = 40;
      const KEY_RIGHT = 39;
      const KEY_LEFT = 37;
      const KEY_BACKSPACE = 8;
      const KEY_M = 77;
      
      const NONE = 0;
      const VERTICAL = 1;
      const HORIZONTAL = 2;
      const MIN_SIZE = 5;
      const MAX_DIVISION = 4;
      
      const EMPTY_TEXTURE = 0;
      const PLAIN_TEXTURE = 1;
      const MIN_TEXTURE = 2;
      
      var map = [];
      var textures = [];
      var color_index = 1;
      
      function get_color() {
        let res = color_index;
        color_index += 1;
        if (color_index == textures.length) {
          color_index = MIN_TEXTURE;
        }
        //console.log("color = " + res + " / " + textures.length);
        return res;
      }
      
      const EMPTY = 0;
      var ROOM_ID = 1;
      var ROOMS = {};
      
      // 2 essais : Lua (1er) Python (2e)
      class Room {
        constructor(map, parent, x, y, width, height) { //, div_type, div_pos, hole, parent) {
          this.map = map;
          this.x = x;
          this.y = y;
          this.w = width; // col max
          this.h = height; // row max
          this.tx = null;
          this.ty = null;
          this.tw = null;
          this.th = null;
          this.color = get_color();
          this.hole = null;
          this.parent = parent;
          if (this.parent == null) {
            this.level = 0;
          } else {
            this.level = this.parent.level + 1;
          }
          this.id = ROOM_ID;
          ROOM_ID += 1;
          ROOMS[this.id] = this;
          this.div = 0;
          this.top = null;
          this.bottom = null;
          this.left = null;
          this.right = null;
          this.sibling = null;
          console.log("  ".repeat(this.level) + "Creating room @" + this.id + " x=" + x + " y=" + y + " width/colmax=" + width + " height/rowmax=" + height + " on map col=" + map[0].length + " row=" + map.length);
        }
        
        has_child() {
          return (this.div != 0);
          //return (!(this.top == null && this.bottom == null && this.left == null && this.right == null));
        }
        
        vertical() {
          return (this.parent.left != null);
        }
        
        horizontal() {
          return (this.parent.top != null);
        }
        
        first() {
          if (this.top != null) {
            return (this.top);
          } else if (this.left != null) {
            return (this.left);
          } else {
            throw "No first child.";
          }
        }
        
        second() {
          if (this.bottom != null) {
            return (this.bottom);
          } else if (this.right != null) {
            return (this.right);
          } else {
            throw "No second child.";
          }
        }
        
        divide(times) {
          if (this.has_child()) {
            throw "Can divide this room, already divided";
          }
          let length = 0;
          let intent = NONE;
          if (this.w > this.h) {
            length = this.w;
            intent = VERTICAL;
          } else {
            length = this.h;
            intent = HORIZONTAL;
          }
          if (length > MIN_SIZE * 2 + 1) {
            if (length & 1) { // odd
              // 0 1 2 3 4 5 6 7 8 => 9
              // length / 2 = 4, possible = 3, 4, 5 soit -1, 0, 1
              this.div = getRandomIntInclusive(1, 3) - 2 + Math.floor(length / 2);
            } else { // even
              // 0 1 2 3 4 5 6 7 8 9 => 10
              // length / 2 = 5, possible = 3, 4, 5, 6 soit -2 -1 0 1
              this.div = getRandomIntInclusive(1, 4) - 3 + length / 2;
            }
            // Create the two children
            if (intent == VERTICAL) {
              this.left = new Room(map, this, this.x, this.y, this.div, this.h);
              this.right = new Room(map, this, this.x + this.div, this.y, this.w - this.div, this.h);
              this.left.sibling = this.right;
              this.right.sibling = this.left;
            } else {
              this.top = new Room(map, this, this.x, this.y, this.w, this.div);
              this.bottom = new Room(map, this, this.x, this.y + this.div, this.w, this.h - this.div);
              this.top.sibling = this.bottom;
              this.bottom.sibling = this.top;
            }
            // Divide
            if (times - 1 > 0) {
              this.first().divide(times - 1);
              this.second().divide(times - 1);
            }
          }
        }
        
        // make the room into the BSP leaves
        dig() {
          if (this.has_child()) {
            this.first().dig();
            this.second().dig();
          } else {
            if (this.w - 2 < MIN_SIZE) {
              this.tw = this.w;
              this.tx = this.x;
              //throw "width " + this.w + " is too small!";
            } else {
              this.tw = getRandomIntInclusive(MIN_SIZE, this.w - 2);
              this.tx = this.x + getRandomIntInclusive(0, this.w - 2 - this.tw);
            }
            if (this.h - 2 < MIN_SIZE) {
              this.th = this.h;
              this.ty = this.y;
              //throw "height " + this.h + " is too small!";
            } else {
              this.th = getRandomIntInclusive(MIN_SIZE, this.h - 2);
              this.ty = this.y + getRandomIntInclusive(0, this.h - 2 - this.th);
            }
          }
        }
        
        // make the hole to connect rooms
        spade() {
          if (this.has_child()) {
            // pass the order to make a hole
            this.first().spade();
            this.second().spade();
            // make a hole for yourself by looking at your child
            // TODO
            if (this.parent != null && this == this.parent.first()) { // only the first child will do something
                console.log("What do to?");
                console.log(this.first().hole);
                console.log(this.second().hole);
            }
          } else { // no child = it is a leaf
            // make a hole for yourself without children IF you are the first child
            // take always the smallest starting point and dimension between first and second child
            if (this == this.parent.first()) {
              if (this.vertical()) { // I'm on top
                let xcol = this.tx + this.tw - 1;
                let smallest_y = Math.max(this.ty, this.sibling.ty);
                let smallest_h = Math.min(this.th, this.sibling.th);
                let yrow = getRandomIntInclusive(smallest_y + 1, smallest_y + smallest_h - 2);
                this.hole = [xcol, yrow] ; 
                console.log("hole col= " + this.hole[0] + " row= " + this.hole[1] + " for vertical room " + this.id);
                // the other hole
                this.sibling.hole = [this.sibling.tx, yrow];
                // spade until the other room
                for (let xcol = this.tx + this.tw; xcol <= this.sibling.tx; xcol++) {
                  this.map[yrow][xcol] = EMPTY;
                  if (xcol < this.sibling.tx) {
                    this.map[yrow-1][xcol] = this.id;
                    this.map[yrow+1][xcol] = this.id;
                  }
                }
              } else { // I'm on the right
                let yrow = this.ty + this.th - 1;
                let smallest_x = Math.max(this.tx, this.sibling.tx);
                let smallest_w = Math.min(this.tw, this.sibling.tw);
                let xcol = getRandomIntInclusive(smallest_x + 1, smallest_x + smallest_w - 2);
                this.hole = [xcol, yrow]; 
                console.log("hole col= " + this.hole[0] + " row= " + this.hole[1] + " for horizontal room " + this.id);
                // the other hole
                this.sibling.hole = [xcol, this.sibling.ty];
                // spade until the other room
                for (let yrow = this.ty + this.th; yrow <= this.sibling.ty; yrow++) {
                  this.map[yrow][xcol] = EMPTY;
                  if (yrow < this.sibling.ty) {
                    this.map[yrow][xcol-1] = this.id;
                    this.map[yrow][xcol+1] = this.id;
                  }
                }
              }
            }
          }
        }
        
        draw() {
          if (this.has_child()) {
            this.first().draw();
            this.second().draw();
          } else {
            for (let row = this.ty; row < this.ty + this.th; row++) {
              for (let col = this.tx; col < this.tx + this.tw; col++) {
                if (row >= this.map.length || col >= this.map[0].length) {
                  throw "Map is too small for this room: row=" + row + " col=" + col + "/" + this.w;
                }
                if (row == this.ty || row == this.ty + this.th - 1 || col == this.tx || col == this.tx + this.tw - 1) {
                  if (this.hole == null || row != this.hole[1] || col != this.hole[0]) {
                    this.map[row][col] = this.id;
                  } else {
                    this.map[row][col] = EMPTY;
                  }
                } else {
                  this.map[row][col] = EMPTY;
                }
              }
            }
          }
        }
        
      }
      
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      function make_dungeon(map) {
        for (let row = 0; row < CAM_MAX_ROW; row++) {
          map.push([])
          for (let col = 0; col < CAM_MAX_COL; col++) {
            map[row].push(PLAIN_TEXTURE);
          }
        }
        let room = new Room(map, null, 0, 0, CAM_MAX_COL, CAM_MAX_ROW); // x y width height
        room.divide(MAX_DIVISION);
        room.dig();
        room.spade();
        room.draw();
        console.log(map);
        return room;
      }
      
      function load() {
        for (let o of document.images) {
          textures.push(o);
          //textures[o.id] = o;
        }
        console.log("End loading " + textures.length + " textures.");
      }
      
      function start() {
        screen = document.getElementById('screen');
        screen.onmousemove = on_mouse_move;
        window.onclick = on_mouse_left_click;
        window.oncontextmenu = on_mouse_right_click;
        window.onkeydown = on_key_down;
        window.onkeyup = on_key_up;
        window.setInterval(run, 33);
        load();
        let root = make_dungeon(map);
        run();
      }
      
      function run() {
        update();
        draw();
      }
      
      function update() {
      }
      
      function draw() {
        if (screen.getContext) {
          let ctx = screen.getContext('2d');
          ctx.clearRect(0, 0, screen.width, screen.height);
          ctx.font = "10px Arial";
          ctx.fillStyle = "black";
          for (let row = 0; row < CAM_MAX_ROW; row++) {
            for (let col = 0; col < CAM_MAX_COL; col++) {
              let index = map[row][col];
              if (index != EMPTY) {
                let room = ROOMS[index];
                ctx.drawImage(textures[room.color], col * 32, row * 32);
                ctx.fillText(room.id, col * 32 + 10, row * 32 + 10); 
              }
            }
          }
          
          ctx.strokeStyle = 'rgb(0, 255, 0)';
          ctx.strokeRect(Math.floor(mouse_col / 32) * 32, Math.floor(mouse_row / 32) * 32, 32, 32);
            
          //ctx.fillStyle = 'rgb(255, 0, 0)';
          //ctx.fillRect(x, y, this.size, this.size);
          
          //ctx.strokeStyle = 'rgb(255, 242, 0)';
          //ctx.beginPath();
          //ctx.rect(this.x, this.y, this.size*32, this.size*32);
          //ctx.stroke();
          
          //ctx.beginPath();
          //ctx.arc(posx, posy, 10, 0, 2 * Math.PI);
          //ctx.fill();
        }
      }
      
      function on_mouse_move(event) {
        event = event || window.event;
        // Mouse coordinates
        let screenRect = screen.getBoundingClientRect();
        mouse_col = event.pageX - screenRect.left;
        mouse_row = event.pageY - screenRect.top;
        //mouse_map_col = Math.floor(mouse_col / 32) + camera.col;
        //mouse_map_row = Math.floor(mouse_row / 32) + camera.row;
      }
      
      function on_mouse_left_click(event) {
        event = event || window.event;
        console.log('Mouse col:', Math.floor(mouse_col / 32), 'Mouse row:', Math.floor(mouse_row / 32));
      }
      
      function on_mouse_right_click(event) {
        event = event || window.event;
        console.log('Mouse col:', mouse_col, 'Mouse row:', mouse_row);
        return false;     // prevent default menu
      }
      
      function on_key_up(event) {
        event = window.event || event;
        if (event.keyCode == KEY_UP) {
          //...
        } else {
          console.log('Unbound up key:', event.keyCode);
        }
      }
      
      function on_key_down(event){
        event = window.event || event;
        if (event.keyCode == KEY_LEFT) {
          //...
        } else {
          console.log('Unbound down key:', event.keyCode);
        }
      }
      
    </script>
  </body>
</html>