<!DOCTYPE html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="keywords" content="ruby, langage, programmation, cours, damien gouteux">
    <meta name="description" content="Documentation sur Ruby par Damien Gouteux">

    <link rel="shortcut icon" href="favicon.ico" >
    <link rel="icon" type="image/gif" href="favicon.ico" >

    <title>Ruby</title>
    
    <style type="text/css">
        body            { font-family: "Palatino Linotype"; font-size: 14px; color: DarkSlateGray; background-color: #EFEFEF; }

        a               { color: DarkGoldenRod; }
        a:hover         { color: White; background-color: DarkGoldenRod; }
        
        a.d, a.d:hover, a.d:active, a.d:focus, a.d:visited { border: none; outline: none; font-weight: bold; color: SeaGreen; background-color: white;
                        cursor: default; text-decoration: none; }

        h1              { color: SeaGreen; font-size: 64px; font-weight: normal; margin: 0; padding-left: 7px; text-align: left; 
                            text-shadow: 0.09em 0.09em 0.1em DarkGrey; }
        h2              { font-size: 14px; color: SeaGreen; margin-top: 45px; }
        h2.horstexte    { font-size: 14px; color: SeaGreen; margin-top: 25px; }
        h3              { font-size: 14px; color: DarkSlateGray; }
        h4              { font-size: 14px; color: DarkGray; }

        table           { border: 1px solid DarkSlateGray; margin-left:auto; margin-right:auto;}
        th              { border: 1px solid DarkSlateGray; background-color: SeaGreen; color: White; }
        tr              { border: 1px solid DarkSlateGray; text-align: center;}
        tr:nth-child(even) { background-color: rgb(210, 210, 210); }

        table.inv       { border: none; width: 100%; text-align: left; }
        table.inv tr    { border: none; text-align: left; }
        table.inv td    { border: none; }

        div.menu        { border-top: 1px solid SeaGreen; text-align: center; padding-top: 3px; padding-bottom: 3px; margin: 0; font-size: 15px; 
                            border-bottom: 1px solid SeaGreen; }
        div.partie      { border: 1px solid SeaGreen; text-align: left; font-size: 18px; color: SeaGreen; padding: 20px 10px 20px 10px; 
                            margin-top: 20px;}
        div.wrapper     { border: 1px solid SeaGreen; width: 800px; margin: auto; border-radius: 25px; padding: 0;
	                        -moz-border-radius: 25p; -webkit-border-radius: 25px; -o-border-radius: 25px; background-color: #FEFEFE; }
        div.content     { margin: 0; padding: 0; padding-left: 5px; padding-right: 5px; }
        
        p.info          { color: #778899; font-family: consolas; text-align: right; width: 100%;}
        
        header          { padding-left: 3px; padding-right: 3px; }

        p.code          { font-family: Consolas, monaco, monospace; background: #fcf6ea; padding-left: 6px; }
        
        span.code       { font-family: Consolas, monaco, monospace; }
        span.s          { font-family: Consolas, monaco, monospace; color: brown; }
        span.c          { font-family: Consolas, monaco, monospace; color: grey; font-style:italic; } 
        span.k          { font-family: Consolas, monaco, monospace; color: orange; }
        span.i          { font-family: Consolas, monaco, monospace; color: #550000; }

        span.index      { color: purple; text-decoration: underline; }

    </style>
</head>
<body>
<div class="wrapper">
<header>
    <h1>Ruby</h1>
    <p class="info">Introduction au langage de programmation Ruby<br>Damien Gouteux, 2012. Version Alpha 04</p>
</header>
<div class="menu"><a href="http://ran.alwaysdata.net/">Ran</a> | <a href="http://ran.alwaysdata.net/beatrice">Beatrice</a> | <a href="http://ran.alwaysdata.net/cristina">Cristina</a> | <a class="d" href="http://ran.alwaysdata.net/ruby">Ruby</a></div>
<div class="content">

<h2 class="horstexte">Avant-propos</h2>

<table class="inv">
  <tr>
    <td>
    
<p>Cette page est un condensé de notes sur le langage de programmation Ruby, découvert en 2006 par le livre "Ruby in a nutschell", écrit par Yukihiro Matsumoto (Matz) le créateur du langage.</p>

<p>Ruby est un langage orienté objet de façon très poussé, agréable à utiliser et plus bien pourvu en bibliothèques. Venant du Japon, il a mis un peu de temps à percer dans le reste du monde avant le grand boom dû à sa bibliothèque phare pour développer rapidement des applications web : <i>Ruby On Rails</i> ou RoR. De nos jours, la fièvre sur RoR est un peu retombée, notamment car des bibliothèques pour d'autres langages ont copié ses apports. Il n'en reste pas moins que les qualités propres à Ruby sont toujours là, et si vous venez de C#, Java, Python ou PHP, pour votre culture informatique ou bien par simple curiosité, Ruby a de belles choses à offrir.</p>

<p>Vous pouvez me contacter à damien POINT gouteux AROBASE gmail.com, en remplaçant les mots en majuscule par le symbole correspondant. Bonne lecture et merci pour votre temps, la chose la plus précieuse de l'univers.</p>

<p>Damien Gouteux, Toulouse, le 7 avril 2012.</p>

<p>P.S. : cette page ne contient pas de pubs, surfez tranquille !</p>

    </td>
    <td align="right">
      <a href="http://fr.wikipedia.org/wiki/Rubis"><img src="http://upload.wikimedia.org/wikipedia/commons/0/0d/Ruby_cristal.jpg" width="300" height="481" alt="Cristal de Rubis"/></a>
    </td>
  </tr>
</table>

<h2 class="horstexte" id="sommaire">Sommaire</h2>

<ol type="I">
  <li>Introduction</li>
  <li><b>Mise en route et rappels</b>
    <ol>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#organisation">Organisation d'un programme Ruby</a>
        <ol type="i">
          <li><a href="#commentaires">Commentaires</a></li>
          <li><a href="#litteraux">Littéraux</a></li>
          <li><a href="#variables">Variables</a></li>
          <li><a href="#constantes">Constantes</a></li>
          <li><a href="#methodes">Méthodes</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><b>Le langage Ruby</b>
    <ol>
      <li><a href="#types">Types de base</a>
        <ol type="i">
          <li><a href="#types1">Tableau résumé des types principaux</a></li>
          <li><a href="#nil">La valeur nulle</a></li>
          <li><a href="#num_string">Nombres et chaînes de caractères</a></li>
          <li><a href="#bool">Booléens</a></li>
          <li><a href="#list">Listes</a></li>
          <li><a href="#dict">Dictionnaires</a></li>
        </ol>
      </li>
      <li><a href="#operateurs">Opérateurs</a>
        <ol type="i">
          <li><a href="#priorites">Priorités</a></li>
          <li><a href="#affectation">Affectation</a></li>
          <li><a href="#transtypage">Transtypage</a></li>
        </ol>
      </li>
      <li><a href="#flux">Contrôle de flux</a>
        <ol type="i">
          <li><a href="#sequence">Séquence</a></li>
          <li><a href="#selection">Sélection</a></li>
          <li><a href="#iteration">Itération</a></li>
          <li><a href="#blocs">Blocs</a></li>
        </ol>
      </li>
      <li><a href="#methodes2">Méthodes</a>
        <ol type="i">
          <li><a href="#appel">Appels de méthodes</a></li>
          <li><a href="#definition">Définition de méthodes</a></li>
          <li><a href="#parametres">Paramètres de méthodes</a></li>
        </ol>
      </li>
      <li><a href="#oo">Classes et objets</a>
        <ol type="i">
          <li><a href="#oo1">Premiers pas dans l'orienté objet</a></li>
          <li><a href="#methodes3">Les méthodes dans l'OO</a></li>
          <li><a href="#encapsulation">L’encapsulation</a></li>
        </ol>
      </li>
      <li><a href="#modules">Modularité</a></li>
      <li><a href="#exceptions">Gestions des exceptions</a></li>
    </ol>
  </li>
  <li><b>Les bibliothèques</b>
    <ol>
      <li><a href="#bibliotheques">Bibliothèque noyau</a></li>
      <li><a href="#bibliotheques">Bibliothèque standard</a></li>
      <li><a href="#bibliotheques">Divers bibliothèques</a></li>
    </ol>
  </li>
  <li><b>Annexes</b>
    <ol>
      <li><a href="#astuces">Astuces</a></li>
      <li><a href="#biblio">Bibliographie</a></li>
      <li><a href="#liens">Liens</a></li>
      <li><a href="#resume">Résumé</a></li>
      <li><a href="#index">Index</a></li>
      <li><a href="#historique">Historique du document</a></li>
    </ol>
  </li>
</ol>

<h2 class="horstexte">Introduction</h2>

<p><a href="http://fr.wikipedia.org/wiki/Ruby">Ruby</a> est un langage de script : interprété et de haut niveau. Il est orienté objet (TOUT est objet) et dispose d’une bibliothèque importante de classes prédéfinies. Il est disponible sous les termes de la licence GNU GPL et de la licence Ruby, et fonctionne sur la plupart des plates-formes du marché (notamment Mac OS X, Windows, Linux et Unix).</p>

<p>Ruby a été créé au Japon par Yukihiro Matsumoto, connu sous le pseudonyme "Matz". Il commença à travailler dessus en 1993, et la première version sortit en 1995. Par tradition, les nouvelles versions du langage sortent aux environs de Noël (peut être parce que Matz est d'obédience chrétienne ?). La dernier version stable a été publiée le 30 octobre 2011, il s'agit de la 1.9.3. Le nom Ruby vient en référence à Perl, un langage de script plus vieux dont Ruby se veut le "successeur". Le livre de référence (en anglais), de Dave Thomas et Andrew Hunt, <i>Programming Ruby</i>, est surnommé le Pickaxe en référence à sa couverture (une pioche).</p>

<p>En plus de Perl, Ruby est assez proche du langage Python. La motivation première pour la création de Ruby était d'apporter l'orienté objet aux langages de script, ce qu'aucun des deux langages ne faisaient à l'époque. Bien qu'au fil des ans, ces deux langages aient évolué pour permettre aux programmeurs l'accès à ce paradigme, Ruby est le seul à avoir été pensé dès le début dans cette optique. Cela lui donne une cohérence, une élégance et une puissance plus grande car il n'a pas à garder un encombrant héritage non-objet. La syntaxe quand à elle, a des parentés avec Eiffel et Ada, en en supprimant toutefois la complexité et la verbosité. Quand au paradigme objet en lui même, son implémentation se rapproche beaucoup du langage précurseur Smalltalk.</p>

<p>L'interpréteur officiel de Ruby est écrit en C. D'autres interpréteurs existent, à destination de la JVM (JRuby), de la CLR (IronRuby), et de Parrot (Cardinal). Il existe également Rubinius, une machine virtuelle elle-même implémentée en Ruby, semblable au projet PyPY pour Python. Depuis le 1er janvier 2007, l'interpréteur officiel est basé sur le projet YARV, apportant un gain notable de performance, longtemps le talon d'Achille de Ruby.</p>

<p>Ruby se présente sous la forme d'un interpréteur en ligne de commande, nommé irb, pour Interactive Ruby, permettant d'évaluer rapidement quelques lignes de code, ou bien d'un interpréteur nommé ruby, auquel on va passer le script, stocké dans un fichier avec l'extension <i>.rb</i>, à interpréter. Ruby est supporté par <a href="http://netbeans.org/features/ruby/index.html">Netbeans</a> et <a href="http://www.ibm.com/developerworks/opensource/library/os-rubyeclipse/">Eclipse</a>, ainsi que par un IDE dédié: <a href="http://www.jetbrains.com/ruby/">RubyMine</a>. De nombreux éditeurs de texte, comme <a href="http://notepad-plus-plus.org/fr/">Notepad++</a> sous windows, offre la coloration syntaxique des fichiers en Ruby.</p>

<!------------------------------------------------ PREMIERE PARTIE ---------------------------------------------------->

<div class="partie">Première partie : Mise en route et rappels</div>

<!------------------------------------------------ I. INSTALLATION  --------------------------------------------------->

<h2 id="installation">Installation</h3>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Pour l'installer allez sur le site de <a href="http://www.ruby-lang.org/fr/"">Ruby</a>, rubrique <a href="http://www.ruby-lang.org/fr/downloads/">Téléchargements</a>. Il est préférable pour Windows de choisir le <a href="http://rubyinstaller.org/">RubyInstaller</a>, qui est un installateur facile d'usage et qui apporte, en sus de Ruby, de nombreuses bibliothèques intéressantes.</p>

<p>Si votre système Linux le supporte, vous pouvez faire <span class="code">sudo apt-get install ruby</span>.</p>

<p>Sur Mac OS X, il vaut mieux passer par le site <a href="http://www.macruby.org/">MacRuby</a> qui offre une très bonne implémentation de Ruby.</p>

<p>Irb est une console Ruby où on peut taper directement du code Ruby qui est exécuté de manière directe et immédiate. Très pratique pour expérimenter rapidement, il suffit d'ouvrir une console (en appuyant simultanément sur les touches windows et R sous Windows, ou avec un terminal sous Linux et Mac OS) et de taper <span class="code">irb</span> dans celle-ci pour que l'interpréteur interactif se lance. Si vous avez des problèmes pour taper les caractères { et } qui ne s’affichent pas, au lieu de <span class="code">irb</span>, entrez <span class="code">irb --noreadline</span> pour résoudre ce problème.</p>

<p>Vous pouvez également utiliser irb sur Internet, sans aucune installation sur votre machine à <a href="http://tryruby.org/levels/1/challenges/0">cette adresse</a>.</p>

<p>Pour faire votre premier programme, ouvrez irb et faites :</p>

<p class="code">
    puts <span class="s">"Hello World!"</span> <span class="c"># Affiche Hello World!</span><br>
</p>

<p>Et voilà ! Vous êtes à présent un Nuby (un newbie en Ruby).</p>

<h2 id="organisation">Organisation d'un programme Ruby</h3>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>En Ruby, le code d'un programme est une suite d'expressions. Une expression peut être un calcul simple comme <span class="code">5 + 2</span>, ou bien une instruction de sélection comme <span class="k">if</span> ou <span class="k">while</span>.</p>

<p>Une autre forme d'expression possible est l'appel à une méthode avec des arguments. Le premier exemple montre cela : <span class="code">puts</span> est la méthode du noyau de Ruby qui affiche un objet, passé en argument, sur la sortie standard et saute à la ligne suivante. On peut entourer le paramètre de parenthèse. <span class="code">print</span> est une autre méthode qui fait la même chose mais sans passer à la ligne suivante. Toutes les expressions suivantes sont équivalentes, sachant que le caractère <b>\n</b> symbolise un saut de ligne.</p>

<p class="code">
    print <span class="s">"Hello World!\n"</span><br>
    print (<span class="s">"Hello World!\n"</span>)<br>
    puts <span class="s">"Hello World!"</span><br>
    puts (<span class="s">"Hello World!"</span>)<br>
</p>

<p>Normalement, les expressions sont évaluées à les unes à la suite des autres, en partant de la première venant dans le fichier contenant le programme. Mais Ruby permet aussi de préciser un code à exécuter au début du programme avec les blocs <span class="k">BEGIN</span><span class="code"> {... }</span> et à la fin <span class="k">END</span><span class="code"> { ...}</span>.</p>

<p>Le code suivant affichera Hello World! sur deux lignes :</p>

<p class="code">
    puts <span class="s">'World!'</span><br>
    <span class="k">BEGIN</span> {<br>
    &nbsp;&nbsp;puts <span class="s">'Hello'</span><br>
    }<br>
</p>

<h3 id="commentaires">Commentaires</h3>

<p>Un commentaire est une information laissée dans le code source par un programmeur. Un commentaire apporte une information utile qui aide à comprendre ce que fait le code ou pourquoi il le fait ainsi. Un commentaire commence par un <span class="c">#</span> et se poursuit jusqu'à la fin de la ligne.</p>

<p class="code">
    <span class="c"># commentaire jusqu'à la fin de la ligne</span><br>
</p>

<h3 id="litteraux">Littéraux</h3>

<p>Un littéral est une valeur écrite "en dur" dans le code. Dans l'expression <span class="code">5 + 2</span>, 5 et 2 sont des valeurs entières écrites en dur, donc des littéraux. On peut ainsi écrire des types simples : nombres entiers <span class="i">5</span>, réels <span class="i">2.3</span> ; ou bien plus complexes : chaînes de caractères <span class="s">"hello"</span>, listes <span class="code">[ 1, 2, 3 ]</span>, etc.</p>

<h3 id="variables">Variables</h3>

<p>Une variable est un concept qui se décompose de deux éléments : un <span class="index">identificateur</span> et une <span class="index">valeur</span> que l'identificateur désigne. Voici deux exemples de déclaration de variables, <span class="code">nom</span> et <span class="code">chiffre</span>.</p>

<p class="code">
    nom = <span class="s">'bonjour'</span><br>
    chiffre = <span class="i">5</span><br>
</p>

<p>Lorsque l'on déclare une variable, on doit spécifier sa valeur, via l'opérateur d'affectation. La première reçoit une valeur qui est la chaîne de caractère <span class="s">'bonjour'</span> et la seconde l'entier <span class="i">5</span>. La valeur de la variable est toujours typée, on peut accéder à son type en utilisant la méthode <span class="code">class</span> (on voit ici une nouvelle manière d'appeler une méthode, en l'associant à un objet via l'opérateur <b>.</b>).</p>

<p class="code">
    puts nom.class &nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Affiche String, c'est à dire une chaîne de caractère</span><br>
    puts chiffre.class <span class="c"># Affiche Fixnum, c'est à dire un entier</span><br>
</p>

<p>Au cours de l'exécution du programme, une variable peut changer de valeur, à nouveau en utilisant l'opérateur d'affectation. L'identificateur désignera alors la nouvelle valeur qui peut être d'un type différent que la précédente valeur.</p>

<p class="code">
    nom = 5 &nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># La variable nom contient un entier</span><br>
    nom = 'abc' <span class="c"># La variable nom contient à présent une chaîne</span><br>
</p>

<p>En Ruby, tous les éléments manipulés sont des objets. Les littéraux <span class="i">5</span> et <span class="s">'bonjour'</span> sont des objets, ainsi que les variables <span class="code">nom</span> et <span class="code">chiffre</span>. Voici un exemple utilisant l'affectation entre deux variables (et non d'un plus l'affectation d'un littéral à une variable) :</p>

<p class="code">
    a = <span class="i">5</span><br>
    b = a<br>
    a = <span class="i">7</span><br>
    puts a <span class="c"># Affiche 7</span><br>
    puts b <span class="c"># Affiche 5</span><br>
</p>

<p>Nous avons ici deux variables, <span class="code">a</span> et <span class="code">b</span>. <span class="code">a</span> référence la valeur 5. Puis <span class="code">a</span> et affecté à <span class="code">b</span>. <span class="code">a</span> et <span class="code">b</span> désigne donc la même valeur à ce moment là, <span class="i">5</span>. Puis on assigne à la variable <span class="code">a</span> une nouvelle valeur, <span class="i">7</span>. Que désignera <span class="code">b</span> dans ce cas ? Et bien toujours <span class="code">5</span> ! Il faut penser l'opérateur d'affectation comme la création d'un lien entre l'identificateur et la valeur, qui change donc le contenu de la variable, et bien voir que deux variables peuvent partager la même valeur. Voici un autre exemple :</p>

<p class="code">
    a = <span class="s">"abc"</span><br>
    b = a<br>
    a.capitalize!<br>
    puts a <span class="c"># Affiche Abc</span><br>
    puts b <span class="c"># Affiche Abc</span><br>
</p>

<p>Ici, <span class="code">b = a</span> effectue la copie de la référence, c'est à dire que b et a désigne le même objet, <span class="s">"abc"</span>. On modifie l'objet via l'appel de la méthode <span class="code">capitalize!</span> en passant par l'identificateur a. Mais b désignant le même objet, donc quand on cherche à afficher la valeur de b, on a exactement la même que celle de a, celle qui a été modifiée par l'appel de la méthode.</p>

<p>On remarquera qui si une variable peut se trouver à gauche ou à droite de l'opérateur d'affectation <b>=</b>, un littéral ne peut être qu'à droite.</p>

<p>Pour savoir si une variable est définie, on utilisera la méthode <span class="code">defined?</span> avec la variable en argument.</p>

<p class="code">
    a = 5 <br>
    defined? a <span class="c"># Retourne "local-variable".</span><br>
    defined? b <span class="c"># Retourne la valeur nulle, nil</span><br>
</p>

<p>Les variables ont une <span class="index">portée</span> et une <span class="index">visibilité</span>. La portée est jusqu'où dans le code la variable vivra avant d'être détruite, alors que la visibilité est sa capacité à être vue. Voici un exemple concret utilisant la définition d'une méthode :</p>

<p class="code">
    b = 22
    <span class="k">def</span> hello<br>
    &nbsp;&nbsp;<span class="c">Ici b n'est pas visible !</span><br>
    &nbsp;&nbsp;a = 5<br>
    <span class="k">end</span><br>
    hello &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># On exécute la méthode hello</span><br>
    defined? a <span class="c"># Retourne nil : a n'est pas défini ici</span><br>
</p>

<p>Le code de la méthode hello définit une variable a. Sa portée et sa visibilité sont limitées à la méthode elle-même. Une fois celle-ci exécutée, la variable a est détruite.</p>

<p>Il existe des variables, appelées variables globales, qui peuvent être vues depuis n'importe où dans le code et qui ne seront détruire qu'à la fin du programme. Les variables globales commencent par un <b>$</b>. Plusieurs sont prédéfinies et accessibles et on peut déclarer les nôtres mais il ne faut pas en abuser :</p>

<p class="code">
    $0 <span class="c"># Retourne le nom du script lancé ou "irb" si on l'utilise</span><br>
    <br>
    $b = <span class="i">22</span><br>
    <span class="k">def</span> hello<br>
    &nbsp;&nbsp;<span class="c">Ici $b est visible car globale !</span><br>
    &nbsp;&nbsp;a = $b<br>
    <span class="k">end</span><br>
    hello &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># On exécute la méthode hello</span><br>
</p>

<p>Par convention, on écrit les noms de variables en minuscules, et si le nom est composé de plusieurs mots, on les sépare par des soulignés ou tirets bas (<b>_</b>).</p>

<h3 id="constantes">Constantes</h3>

<p>Une constante est une variable spéciale dont le lien entre son identificateur et la valeur ne peut changer. C'est à dire une fois le lien formé, il ne doit pas être défait. En Ruby, une constante est indiquée par le premier caractère de son identificateur en majuscule. L'identificateur peut être entièrement en majuscule pour faciliter son repérage dans le code. Tenter de changer une constante aboutira à un avertissement en Ruby, mais le changement sera tout de même effectué.</p>

<p class="code">
    A = <span class="s">"abc"</span><br>
    A = <span class="s">"def"</span> <span class="c"># Déclenche un avertissement.</span><br>
</p>

<p>Il y a trois conceptions de la constance possibles : la première, c'est la constance du lien identificateur-valeur, c'est cette conception que Ruby implémente. La seconde c'est la constance de la valeur elle-même : c'est l'impossibilité de changer la valeur. En Ruby, on peut changer la valeur d'une constante.</p>

<p class="code">
    A = <span class="s">"abc"</span><br>
    A.capitalize! <span class="c"># La valeur de A est maintenant Abc.</span><br>
</p>

<p>Pour avoir cette constance de valeur, on utilisera la méthode <span class="code">freeze</span>. Une fois gelée, la valeur ne pourra plus être modifiée.</p>

<p class="code">
    A = <span class="s">"abc"</span><br>
    A.freeze<br>
    A.capitalize! <span class="c"># Impossible ! Cela déclenche une erreur.</span><br>
</p>

<p>Une dernière forme de constance est la constance de type. C'est à dire qu'un identificateur donné ne peut référencer que des valeurs de même type. En Ruby, c'est le lien identificateur-valeur qui est constant, donc la constance de type est achevée dans ce sens. Les variables, elles, peuvent successivement prendre n'importe quelle valeur de n'importe quelle type.</p>

<p class="code">
    a = <span class="s">"abc"</span><br>
    a.class <span class="c"># Retourne String</span><br>
    a = <span class="i">5</span><br>
    a.class <span class="c"># Retourne Fixnum</span><br>
</p>

<p>Pour savoir de quel type est une variable ou une constante, on peut passer par la méthode <span class="code">class</span> que nous avons vu précédemment, qui retourne son type, ou bien la méthode <span class="code">instance_of?</span> qui renvoit vrai si la variable est du type passé en paramètre.</p>

<p class="code">
    a = <span class="s">"abc"</span><br>
    a.instance_of? String <span class="c"># Retourne true</span><br>
    a = <span class="i">5</span><br>
    a.instance_of? Fixnum <span class="c"># Retourne Fixnum</span><br>
</p>

<p>Les constantes ont une visibilité globale par défaut, il ne faut donc pas mettre de <b>$</b> au début d'une constante.</p>

<h3 id="methodes">Méthodes</h3>

<p>Une méthode (ou fonction, ou sous-programme) est une partie de code qui n'est pas exécuté de suite, mais peut être exécuté à n'importe quel moment en exécutant la méthode, on parle alors d'appel de la méthode. Pour utiliser une méthode, il y a donc deux phases : la définition de celle-ci, puis son appel. Reprenons l'exemple précédent :</p>

<p class="code">
    <span class="k">def</span> hello<br>
    &nbsp;&nbsp;a = <span class="i">5</span><br>
    <span class="k">end</span><br>
    hello <span class="c"># On exécute la méthode hello</span><br>
    defined? a <span class="c"># Retourne nil : a n'est pas défini ici.</span><br>
</p>

<p>Cette méthode s'appelle <span class="code">hello</span>. Lorsque elle est appelée, son code est exécuté un résultat est toujours renvoyé. Ici, ce sera le résultat de la dernière expression évaluée, qui est <span class="code">a = </span><span class="i">5</span>, donc 5.</p>

<p>Une méthode est en fait, comme les constantes, un genre de variable particulier. On a bien un identificateur, <span class="code">hello</span>, et sa valeur qui est le code.</p>

<p>On peut créer un alias pour une méthode, c'est à dire un deuxième identificateur qui renverra à la même valeur.</p>

<p class="code">
    <span class="k">alias</span> :bonjour :hello<br>
    bonjour <span class="c"># On exécute la méthode hello via l'identificateur bonjour</span><br>
</p>

<p>On a vu également un autre moyen d'appeler une méthode : la syntaxe <span class="code">objet.méthode(paramètres)</span>. On dit que le message <span class="code">méthode</span> est passé l'objet. En fait, ce moyen est le seul. Lorsque nous appelons dans notre programme directement une méthode sans préciser l'objet, le message sera envoyé à un objet par défaut, auquel on peut accéder par la variable <span class="code">self</span>.</p>

<p class="code">
    self.class <span class="c"># Retourne Object</span><br>
    <br>
    <span class="k">def</span> hello<br>
    &nbsp;&nbsp;puts <span class="s">"hello"</span><br>
    <span class="k">end</span><br>
    <br>
    hello &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Affiche "hello"</span><br>
    self.hello <span class="c"># Affiche "hello"</span><br>
</p>

<p>Les deux dernières lignes sont donc équivalentes. Chaque objet peut donc répondre à un certains nombres de messages propre à lui-même ou à son type. Voici quelques exemples :</p>

<p class="code">
    4.next &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 5</span><br>
    <span class="s">"hello "</span>.concat(<span class="s">"world"</span>) <span class="c"># Retourne "hello world"</span><br>
    
</p>

<p>Par convention, le nom d'une méthode est toujours en minuscule. S'il comporte plusieurs mots, on les sépare par un souligné ou tiret bas (<b>_</b>). Si une méthode retourne un résultat de type booléen (vrai ou faux), on terminera son nom par un point d'intérrogation. Si la méthode modifie l'objet sur lequel elle est appelée, on terminera son nom par un point d'exclamation. Exemples : <span class="code">instance_of?, capitalize!</span>.</p>

<p>Il est donc important de connaître les différents types de Ruby, et les différentes méthodes dont-ils disposent.</p>

<!-------------------------------------- SECONDE PARTIE : RUBY ---------------------------------------->

<!---------------------------------------- I. Types de base ------------------------------------------->

<h2 class="horstexte" id="types">Types de base</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<h3 id="types1">Tableau résumé des types principaux</h3>

<table>
  <thead>
    <tr><th>Type</th><th>Nom en Ruby</th><th>Mode de copie</th><th>Exemples</th></tr>
  </thead>
  <tr><td>Entier</td><td>Fixnum, Bignum</td><td>Valeur</td><td>1 010 (8 en octal) 0x10 (16 en hexa)<br>0b10 (2 en binaire) 124_345 (ignoré)</td></tr>
  <tr><td>Réel</td><td>Float</td><td>Valeur</td><td>1.2 1e10</td></tr>
  <tr><td>Booléens</td><td>TrueClass<br>FalseClass</td><td>Valeur</td><td><span class="k">true<br>false</span></td></tr>
  <tr><td>Chaîne de caractères</td><td>String</td><td>Référence</td><td>"youpi"<br>'youpi'<br>%s(youpi)</td></tr>
  <tr><td>Liste</td><td>Array</td><td>Référence</td><td>[1, 2, 3]<br>%w(1 2 3)</td></tr>
  <tr><td>Dictionnaire</td><td>Hash</td><td>Référence</td><td>{'a' => 65}</td></tr>
  <tr><td>Interval</td><td>Range</td><td>Référence</td><td>1..2 (inclusif)<br>1...3 (exclusif)</td></tr>
  <tr><td>Symbole</td><td>Symbol</td><td>Référence</td><td>:a</td></tr>
  <tr><td>Valeur nulle</td><td>NilClass</td><td>Référence</td><td><span class="k">nil</span></td></tr>
</table>

<h3 id="nil">La valeur nulle</h3>

<p>Il existe en Ruby une valeur nulle, <span class="k">nil</span>. On peut tester si une variable a pour valeur <span class="k">nil</span> avec la méthode <span class="code">nil?</span></p>

<p class="code">
    a = <span class="k">nil</span><br>
    a.nil? <span class="c"># Retourne vrai</span><br>
</p>

<h3 id="num_string">Nombres et chaînes de caractères</h3>

<p>Voici un exemple d'utilisation dans le code, on va affecter à 4 variables les constantes littérales suivantes :</p>

<p class="code">
    un_reel = <span class="i">3.14</span><br>
    un_entier = <span class="i">5</span><br>
    une_chaine = <span class="s">"bonjour monsieur O'Reilly\n"</span><br>
    une_autre_chaine = <span class="s">'bonjour le "monde"'</span><br>
</p>

<p>On remarque que les chaînes de caractère peuvent s'écrire entre guillemet simple ou double, ou encore avec la construction <span class="code">%s(...)</span>. Cela permet d'utiliser le guillemet simple dans une chaîne délimitée par des guillements doubles et inversement. Seule une chaîne délimitée par des guillemets doubles interprétra les <span class="index" id="car_echap">caractères d'échappement</span>. Ainsi <b>\n</b> sera remplacé par un saut à la ligne.</p>

<p>Tout obéit au paradigme objet dans Ruby. Ainsi on peut directement appeler une méthode sur un littéral, c'est à dire utiliser la forme <span class="code">objet<b>.</b>méthode</span> :</p>
<p class="code">
    <span class="i">5<span>.to_s &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne une chaîne représentant le nombre 5</span><br>
    <span class="s">"bonjour"</span>.upcase &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne une chaîne avec toutes les lettres en majuscule</span><br>
    <span class="s">"bonjour"</span>.include?(<span class="s">'bon'</span>) &nbsp;&nbsp;<span class="c"># Renvoie vrai, car la chaîne bonjour contient bon</span><br>
    <span class="s">"hello world"</span>.length	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Renvoie 11</span><br>
    <span class="s">"hello world"</span>.index(<span class="s">"h"</span>) &nbsp;&nbsp;&nbsp;<span class="c"># Renvoie la position du caractère h : 0</span><br>
    <span class="i">-4</span>.abs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Renvoie la valeur absolue de -4 : 4</span><br>
</p>

<p>true, false, nil, __LINE__, __FILE__ sont appelés <span class="index" id="pseudo_var">pseudo variable</span> et sont inassignables : c'est à dire que comme les constantes littérales, elles ne peuvent apparaître à gauche d'une affectation.</p>

<p>On fera bien attention que <span class="i">99.</span> n'est pas un réel valide en Ruby. En effet, avec la possibilité d'appeler une méthode sur un objet, Ruby ne sera pas interpréter cette notation. Il faut à chaque que l'on veut écrire un réel ainsi, mettre une décimale : <span class="i">99.0</span>.</p>

<h3 id="bool">Booléens</h3>

<p>Le type booléen dispose de deux valeurs : vrai, <span class="code">true</span>, et faux, <span class="code">false</span>.</p>

<p>En Ruby, les valeurs <span class="code">false</span> et <span class="code">nil</span> sont fausses. Tout le reste est vrai, <u>même la valeur 0</u>.</p>

<p>On peut utiliser les opérateurs booléens suivants : <span class="k">and</span>, <span class="k">or</span>, <span class="k">not</span>. Les deux premiers sont des opérateurs binaires, le dernier est unaire. Voici les <a href="http://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9">tables de vérité</a> de ces différents opérateurs :</p>

<table>
  <tr><th>valeur a</th><th>valeur b</th><th>a and b</th><th>a or b</th><th>not a</th></tr>
  <tr><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr>
  <tr><td>false</td><td>true</td><td>false</td><td>true</td><td>true</td></tr>
  <tr><td>true</td><td>false</td><td>false</td><td>true</td><td>false</td></tr>
  <tr><td>true</td><td>true</td><td>true</td><td>true</td><td>false</td></tr>
</table>

<h3 id="list">Listes</h3>

<p>Appelées aussi tableaux. L'expression <span class="code">%w(1 2 3)</span> permet de créer un tableau sans [] mais attention, chaque élément sera une chaîne de caractère. Ainsi : <span class="code">%w(1 2 3)</span> est équivalent à <span class="code">["1", "2", "3"]</span> et pas <span class="code">[1, 2, 3]</span> !</p>

<p>On peut mixer les types de données au sein d'une même liste. Ainsi une liste peut contenir en même temps un entier, une chaîne, un booléen, etc. Chaque élément a une position, numérotée de 0 pour la première à la longueur de la liste-1 pour la dernière. Pour accéder à un élément donné, on utilise l'opérateur <b>[]</b> avec l'indice de sa position. Si l'indice donné ne correspond à aucun élément, la valeur nulle, <span class="k">nil</span> est retournée.</p>

<p class="code">
    vide = [] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Liste vide</span><br>
    vide2 = Array.new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Autre moyen pour avoir une liste vide</span><br>
    liste = [<span class="i">1</span>, <span class="i">2</span>, <span class="s">'bonjour'</span>]<br>
    liste[<span class="i">0</span>] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 1</span><br>
    liste.last &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 'bonjour'</span><br>
    liste[<span class="i">1</span>] = <span class="i">3</span> <span class="c">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Le tableau contient à présent : 1, 3, 'bonjour'</span><br>
    liste.length &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 3</span><br>
    liste.push(<span class="s">'au revoir'</span>) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Ajoute à la fin du tableau 'au revoir'</span><br>
    autre = %w{ chien chat serpent } <span class="c"># Crée la liste ["chient", "chat", "serpent"]</span><br>
</p>

<h3 id="dict">Dictionnaire</h3>

<p>Appelées aussi tableaux associatifs ou <a href="http://fr.wikipedia.org/wiki/Table_de_hachage">table de hachage</a>. Un dictionnaire associe une clé à une valeur. La clé et la valeur peuvent être de n'importe quel type.</p>

<p class="code">
    vide = {}<br>
    dico = { <span class="s">'France'</span> => <span class="s">'Paris'</span>, <span class="s">'Allemagne'</span> => <span class="s">'Berlin'</span>, <span class="s">'Italie'</span> => <span class="s">'Rome'</span> }<br>
    puts dico[<span class="s">'France'</span>] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Affiche Paris</span><br>
    dico[<span class="s">'Espagne'</span>] = <span class="s">'Madrid'</span> <span class="c"># Ajoute une nouvelle paire clé/valeur.</span><br>
    dico.length &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 4</span><br>
    dico.values &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne la liste des valeurs ['Paris', 'Berlin', 'Rome', 'Madrid']</span><br>
    dico.keys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># De même pour les clés ['France', 'Allemagne', 'Italie', 'Espagne']</span><br>
    dico[<span class="s">'Palombie'</span>] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># La valeur nulle (nil) est retournée si la clé n'existe pas</span><br>
    vide2 = Hash.new(<span class="i">0</span>) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Si la clé n'existe pas, 0 sera retourné (nil par défaut)</span><br>
</p>

<!------------------------------------------------ Opérateurs ---------------------------------------------------->

<h2 class="horstexte" id="operateurs">Opérateurs</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Il y a en tout 25 opérateurs. On peut les classifier ainsi :
  <ul>
    <li>Les 6 opérateurs arithmétiques : +, -, /, *, % (modulo), ** (puissance)</li>
    <li>Les 5 opérateurs binaires : &, |, ^, <<, >></li>
    <li>Les 7 opérateurs d’affectation : =, +=, -=, /=, *=, %=, **=</li>
    <li>Les 4 opérateurs de comparaison : <, <=, >, >=, ==, !=</li>
    <li>Les 3 opérateurs booléens : <span class="k">and</span>, <span class="k">or</span>, <span class="k">not</span> ou <span class="code">&&, ||, !</span></li>
  </ul>
</p>

<p>On peut combiner les opérateurs d'arithmétiques avec l'opérateur d'affectation <b>=</b>. On parlera alors d'opérateurs raccourcis :</p>
<p class="code">
    i = i – <span class="i">1</span> <span class="c"># Est équivalent à :</span><br>
    i -= <span class="i">1</span><br>
    i = i * <span class="i">2</span> <span class="c"># Est équivalent à :</span><br>
    i *= <span class="i">2</span><br>
</p>

<p>Il n'y a pas d'opérateurs de pré et post décrémentation (++ et --) en Ruby !</p>

<p>L'utilisation d'un opérateur avec des arguments invalides peut générer une erreur : si l'on fait <span class="i">5</span><span class="code"> / </span><span class="i">0</span> on obtiendra alors une <span class="code">ZeroDivisionError</span>.</p>

<h3 id="priorites">Priorités</h3>

<p>Les opérateurs ont chacun un ordre de priorité. En effet, dans l'expression <span class="i">5</span><span class="code"> + </span><span class="i">2.5</span><span class="code"> * </span><span class="i">2</span>, il est important que l'opérateur <b>*</b> de multiplication s'exécute avant celui d'addition. Le tableau suivant présente les opérateurs par ordre de priorité, de la plus élevée à la plus faible :</p>

<table>
  <tr><th>Opérateurs</th></tr>
  <tr><td>::</td></tr>
  <tr><td>[]</td></tr>
  <tr><td>**</td></tr>
  <tr><td>-(unaire)  +(unaire)  !  ~</td></tr>
  <tr><td>*  /  %</td></tr>
  <tr><td>+  -</td></tr>
  <tr><td><<  >></td></tr>
  <tr><td>&</td></tr>
  <tr><td>|  ^</td></tr>
  <tr><td>>  >=  <  <=</td></tr>
  <tr><td><=> ==  === !=  =~  !~</td></tr>
  <tr><td>&&</td></tr>
  <tr><td>||</td></tr>
  <tr><td>.. ...</td></tr>
  <tr><td>= += -= *= /= %=</td></tr>
  <tr><td>not</td></tr>
  <tr><td>and or</td></tr>
</table>

<h3 id="affectation">Affectation</h3>

<p>L'opérateur d'affectation consiste à lier un identificateur à une valeur. Elle présente plusieurs formers :</p>

<p class="code">
    a = <span class="i">5</span><br>
    a, b = <span class="i">5</span>, <span class="i">6</span><br>
</p>

<p>Dans la dernière ligne, a est associé à la valeur 5 et b à 6. Si il y a plus d'identificateurs à droite que de valeurs à gauche, les derniers recevront la valeur nulle, <span class="k">nil</span>.</p>

<p>On peut utiliser cela aussi pour les tableaux :</p>

<p class="code">
    a = [<span class="i">1</span>, <span class="i">2</span>, <span class="i">3</span>]<br>
    a[0], a[1], a[2] = <span class="s">'a'</span>, <span class="s">'b'</span>, <span class="s">'c'</span><br>
</p>

<h3 id="transtypage">Transtypage</h3>

<p>L'opération de transtypage, ou casting en anglais, consiste à faire transformer une valeur d'un type donné en une valeur correspondante dans un autre type. Ruby utilise des méthodes pour effectuer cela :</p>

<ul>
  <li>to_s : méthode pour obtenir une chaîne</li>
  <li>to_i : méthode pour obtenir un entier d'un flottant ou d'une chaîne</li>
  <li>to_f : méthode pour obtenir un flottant d'un entier ou d'une chaîne</li>
</ul>

<p class="code">
    <span class="s">"5"</span>.to_i + <span class="i">5</span> <span class="c"># On obtient 10</span><br>
</p>

<!------------------------------------------ Contrôle de flux ----------------------------------------------->

<h2 class="horstexte" id="flux">Contrôle de flux</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Le flux est la suite d'instructions exécutées par l'interpréteur Ruby. Normalement, l'exécution est séquentielle, mais nous allons voir qu'elle peut être aussi sélectif et itératif.</p>

<h3 id="sequence">Séquence</h3>
<p class="code">
    instruction-1 <span class="c"># nouvelle ligne</span><br>
    instruction-2<br>
    instruction-3 <b>;</b> instruction-4<br>
</p>

<p>Au contraire de nombreux langages, le <span class="code">';'</span> n'est pas un opérateur de terminaison d'une instruction mais de séparation de deux instructions successives.</p>

<p>On peut réunir les instructions en un morceau de code entouré de <span class="k">begin</span> et <span class="k">end</span>.</p>

<p class="code">
    <span class="k">begin</span><br>
    &nbsp;&nbsp;actions<br>
    <span class="k">end</span><br>
</p>

<h3 id="selection">Sélection</h3>

<p>La sélection est l'acte d'exécuter une instruction si et seulement une condition est réunie. On distingue deux structures pour la sélection : le <span class="k">if</span> qui exécute l'instruction ou les instructions suivantes si la condition est vraie, et le <span class="k">unless</span>, que l'on peut traduire par <i>à moins que, sauf si</i>, qui exécutera le ou les instructions suivantes si la condition est fausse.</p>

<p class="code">
    <span class="k">if</span> condition [<span class="k">then </span>]<br>
    &nbsp;&nbsp;instructions<br>
    [ <span class="k" >elsif</span> condition [<span class="k">then </span>]<br>
    &nbsp;&nbsp;instructions ]*<br>
    [ <span class="k">else</span><br>
    &nbsp;&nbsp;instructions ]<br>
    <span class="k">end</span><br>
    <br>
    <span class="k">unless </span>condition<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
</p>

<p>Une autre forme est de mettre la sélection après l'expression que l'on veut garder par la condition.</p>

<p class="code">
    action <span class="k">if</span> condition<br>
    action <span class="k">unless</span> condition<br>
</p>

<p>Enfin, une dernière forme de sélection propose un choix entre plusieurs valeurs. Les instructions correspondantes à la valeur de l'expression testée seront exécutées (et contrairement à d'autres langages, seulement celles-ci).</p>

<p class="code">
    <span class="k">case</span> expression<br>
    &nbsp;&nbsp;<span class="k">when</span> expression <span class="k">then</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;instructions<br>
    &nbsp;&nbsp;<span class="k">when</span> expression <span class="k">then</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;instructions<br>
    &nbsp;&nbsp;[ <span class="k">else</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;instructions ]<br>
    <span class="k">end</span><br>
</p>

<p>Si la condtion de <span class="k">if</span> est une expression régulière seule, alors elle sera évaluée sur la variable globale $_.</p>

<h4>Exemple</h4>

<p class="code">
    mon_nombre = <span class="i">5</span><br>
    <span class="k">if</span> mon_nombre == <span class="i">5</span><br>
    &nbsp;&nbsp;puts <span class="s">"mon nombre vaut 5"</span><br>
    <span class="k">elsif</span> mon_nombre == <span class="i">4</span><br>
    &nbsp;&nbsp;puts <span class="s">"mon nombre vaut 4"</span><br>
    <span class="k">else</span><br>
    &nbsp;&nbsp;puts <span class="s">"mon nombre ne vaut pas ni 5 ni 4"</span><br>
    <span class="k">end</span><br>
    <span class="c"># Affiche "mon_nombre vaut 5"</span><br>
    <br>
    puts <span class="s">"hello"</span> <span class="k">if</span> mon_nombre == <span class="i">5</span><br>
    <span class="c"># Affiche "hello"</span><br>
</p>

<p>On notera qu'il n'y a pas besoin d'entourer les conditions par des parenthèses, comme dans de nombreux langages.</p>

<h3 id="iteration">Itération</h3>

<p>L'itération est le fait d'exécuter plusieurs fois la même instruction au sein d'une boucle. Généralement, la boucle est gardée par une condition qui est réévaluée à chaque nouvelle itération de la boucle. Il existe deux principales constructions pour faire des boucles en Ruby : <span class="k">for</span> et <span class="k">while</span>. La première parcours une itération en affectant une valeur, et la seconde est une simple boucle gardée par une condition. Il existe aussi <span class="k">until</span> qui à la différence de <span class="k">while</span>, qui exécute la boucle tant que la condition est vraie, exécutera la boucle tant que sa condition sera fausse.</p>

<p class="code">
    <span class="k">for</span> variable <span class="k">in</span> liste_de_valeurs [<span class="k">do</span>]<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
    <br>
    <span class="k">while</span> condition [<span class="k">do</span>]<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
    <br>
    <span class="k">until</span> condition [<span class="k">do</span>]<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
</p>

<p>Comme pour la sélection, une autre possibilité est de mettre la construction itérative après l'expression que l'on veut exécuter plusieurs fois. Dans ce cas, l'instruction est évaluée une première fois, puis la condition de la boucle est vérifiée.</p>

<p class="code">
    instructions <span class="k">while</span> condition<br>
    instructions <span class="k">until</span> condition<br>
</p>

<p>A l'intérieur d'une boucle, l'instruction <span class="k">break</span> permet de casser la boucle et d'en sortir immédiatement. L'instruction <span class="k">next</span> permet elle de passer à l'itération suivante, sans exécuter les instructions restantes de la boucle. Enfin, <span class="k">redo</span> permet de recommencer l'itération actuelle, sans réévaluer la condition de la boucle.</p>

<h3 id="blocs">Blocs</h3>

<p>D'autres constructions, à l'aide de la méthode <span class="code">times</span> par exemple, permettent de faire des boucles. On utilisera alors les blocs. Un bloc est délimité par <span class="k">do</span> et <span class="k">end</span> ou bien <b>{</b> et <b>}</b>. Il peut avoir des paramètres, que l'on mettra au tout début du bloc, encadrés par <b>| ... |</b>. Un bloc fonctionne comme un morceau de code que l'on passe en paramètre d'une méthode.</p>

<p class="code">
    <span class="k">do&nbsp;</span><br>
    &nbsp;&nbsp;|paramètres|<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
    <br>
    {<br>
    &nbsp;&nbsp;|paramètres|<br>
    &nbsp;&nbsp;instructions<br>
    }<br>
</p>

<h4>Exemples</h4>

<p class="code">
    <span class="i">2</span>.times <span class="k">do</span><br>
    &nbsp;&nbsp;puts <span class="s">'bonjour !'</span><br>
    <span class="k">end</span><br>
    <span class="c"># Affiche deux fois "bonjour!"</span><br>
    <br>    
    <span class="k">for</span> x <span class="k">in</span> <span class="i">1</span>..<span class="i">3</span> <span class="k">do</span><br>
    &nbsp;&nbsp;puts x<br>
    <span class="k">end</span><br>
    <span class="c"># Affiche  1, 2, et 3 sur trois lignes.</span><br>
    <br>
    (<span class="i">1</span>..<span class="i">3</span>).each <span class="k">do</span><br>
    &nbsp;&nbsp;|x|<br>
    &nbsp;&nbsp;puts x<br>
    <span class="k">end</span><br>
    <span class="c"># Affiche  1, 2, et 3 sur trois lignes.</span><br>
    <br>
    mon_dic = {<span class="s">'a'</span> => <span class="i">1</span>, <span class="s">'b'</span> => <span class="i">2</span>}<br>
    <span class="k">for</span> key, value <span class="k">in</span> mon_dic<br>
    &nbsp;&nbsp;puts key, value<br>
    <span class="k">end</span><br>
    <span class="c"># Affiche a 1, b 2, à chaque fois sur deux lignes.</span><br>
    <br>
    b = <span class="i">3</span>.times {<br>
    &nbsp;&nbsp;puts <span class="s">'hello'</span><br>
    }<br>
    <span class="c"># Affiche 'hello' trois fois.</span><br>
    <br>
    cpt = 0
    puts (cpt+=<span class="i">1</span>) <span class="k">while</span> cpt < <span class="i">5</span><br>
    <span class="c"># Affiche 1, 2, 3, 4, 5 sur cinq lignes.</span><br>
</p>

<p>Certaines méthodes, comme <span class="code">each, collect, detect</span> sont des itérateurs : elles vont itérer parmi toutes les valeurs de l'objet sur lequel elles sont appelées.</p>

<p class="code">
    [<span class="s">'a'</span>, <span class="s">'b'</span>, <span class="s">'c'</span>].each { |x| puts x }<br>
    <span class="c"># Affiche 'a', 'b', 'c' sur trois lignes.</span><br>
    <br>
    [<span class="s">'a'</span>, <span class="s">'b'</span>, <span class="s">'c'</span>].collect { |word| word.capitalize }<br>
    <span class="c"># Retourne une nouvelle liste ['A', 'B', 'C']</span><br>
    <br>
    [<span class="s">'a'</span>, <span class="s">'b'</span>, <span class="s">'c'</span>].detect { |element| element == <span class="s">'a'</span>}<br>
    <span class="c"># Retourne 'a'</span><br>
</p>

<!------------------------------------------------ Méthodes ---------------------------------------------------->

<h2 class="horstexte" id="methodes2">Méthodes</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Une méthode, appelée aussi fonction, sous-programme ou procédure, est un morceau de code que l'on peut exécuter plusieurs fois, via un appel. L'appel ce fait via l'intermédiaire d'un identifiant, le nom de la méthode. On peut spécifier des paramètres formels pour une méthode, qui seront remplacés, au moment de l'appel, par des paramètres réels (ou effectifs) qui peuvent être différent à chaque appel.</p>

<h3 id="appel">Appels de méthodes</h3>

<p>On doit entourer les paramètres réels seulement si cela pose un problème de compréhension à l'interpréteur. Sinon on peut les omettre. S'il n'y a pas de paramètres, on peut se passer également de parenthèses. Les différents paramètres sont séparés par une virgule. On utilisera dans les exemples la méthode <span class="code">add</span> qui réalise une simple addition de deux paramètres, et la méthode assert_equal vérifiant l'égalité de ses deux paramètres, que nous spécifierons dans le paragraphe suivant.</p>

<p class="code">
    nom (paramètres réels)<br>
    <br>
    puts <span class="s">'bonjour'</span><br>
    puts (<span class="s">'bonjour'</span>)<br>
    <br>
    number = 5<br>
    assert_equal (<span class="i">5</span>, number)<br>
    <br>
    add(2 ,3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 5</span><br>
    add 2, 3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># Retourne 5</span><br>
    add 2, add(3, 4) <span class="c"># Retourne 9</span><br>
</p>

<p>Le nombre de paramètres réels doit correspondre exactement au nombre de paramètres formels définis, sinon une erreur <span class="code">ArgumentError</span> est générée, sauf si une valeur par défaut a été spécifiée pour le paramètre formel. Dans ce dernier cas, le paramètre prendra comme valeur sa valeur par défaut.</p>

<p>En Ruby, l'appel de fonction se fait par passage de messages : le nom de la méthode est un message et l'objet est le receveur de ce message. Si le receveur n'est pas spécifié, l'objet <span class="code">main</span> est utilisé (main est de type <span class="code">Object</span>).</p>

<h3 id="definition">Définition de méthodes</h3>

<h4>Syntaxe</h4>
<p class="code">
    <span class="k">def</span> identifiant(paramètres formels)<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
</p>

<h4>Exemple</h4>
<p class="code">
    <span class="k">def</span> assert_equal(expected, actual)<br>
    &nbsp;&nbsp;<span class="k">if</span> expected != actual<br>
    &nbsp;&nbsp;&nbsp;&nbsp;puts <span class="s">"failed"</span><br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
    <br>
    <span class="k">def</span> add(a, b)<br>
    &nbsp;&nbsp;<span class="k">return</span> a+b<br>
    <span class="k">end</span><br>
</p>

<p>L'instruction <span class="k">return</span> indique que la méthode se termine et renvoit la valeur suivant le mot-clé. Si aucune valeur n'est spécifiée, la valeur nulle est renvoyée. Les méthodes retournent toujours une valeur, et si aucune n'est spécifiée, c'est celle de la dernière expression exécutée dans la méthode qui sera retournée.</p>

<p class="code">
    <span class="k">def</span> five<br>
    &nbsp;&nbsp;<span class="i">5</span> <span class="c"># C'est équivalent à return 5</span><br>
    <span class="k">end</span><br>
    puts five<br>
</p>

<h3 id="parametres">Paramètres de méthodes</h3>

<p>Il y a deux moyens de passer un paramètre : par position ou par nom. On peut mixer les deux, mais les paramètres par position doivent toujours venir en premier et ne peuvent plus être utilisés dès qu'il y a un paramètre par nom qui est passé.</p>

<p class="code">
    <span class="k">def</span> add3(a, b, c)<br>
    &nbsp;&nbsp;<span class="k">return</span> a+b+c<br>
    <span class="k">end</span><br>
    <br>
    add3(2, c=3, b=5) <span class="c"># Retourne 10</span><br>
</p>

<p>On peut aussi définir des valeurs par défaut pour les paramètres.</p>

<p class="code">
    <span class="k">def</span> add3(a=1, b=2, c=2)<br>
    &nbsp;&nbsp;<span class="k">return</span> a+b+c<br>
    <span class="k">end</span><br>
    <br>
    add3(0) <span class="c"># Retourne 4. a est mis à 0.</span><br>
</p>

<p>Il existe également des paramètres spéciaux, qui doivent être mis à la fin des paramètres formels dans la définition de la fonction. Il ne peut y en avoir qu'un de chaque type, et l'ordre doit être respecté. Le premier type est symbolisé par le préfixe <b>*</b> et contiendra tous les paramètres supplémentaires passés à la fonction dans une liste. Le second type est préfixé par <b>**</b> et contidendra tous les paramètres supplémentaires passés par nom dans un dictionnaire où le nom sera utilisé comme clé. Enfin le dernier type est préfixé par <b>&</b> et permet de passer un bloc à la méthode. Ce bloc peut être appelé à l'intérieur de la fonction à l'aide du mot clé <span class="k">yield</span> suivit du nombre de paramètres nécessaires à l'exécution du bloc.</p>

<p class="code">
    <span class="k">def</span> make_something_on_list(*liste, &action)<br>
    &nbsp;&nbsp;<span class="k">for</span> i <span class="k">in</span> liste <span class="k">do</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;yield i<br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
    <br>
    make_something_on_list(1, 2, 3) do |i| puts i end <span class="c"># Affiche 1, 2, 3 sur trois lignes.</span><br>
</p>

<p>Lorsque l'on exécute un appel d'une méthode, celle-ci doit être définie à ce moment de l'exécution. Mais on peut la mentionner avant dans le corps d'autres méthodes, tant que celles-ci ne sont pas appelées.</p>

<p>On peut annuler la définition d'une méthode avec le mot clé <span class="k">undef</span>.

<p class="code">
    <span class="k">undef</span> :make_something_on_list<br>
</p>

<p>On peut faire des méthodes enchâssées, c'est à dire des définitions de méthode dans une méthode.</p>

<h4>Exemples</h4>

<p class="code">
    <span class="k">def</span> sayHello(name)<br>
    &nbsp;result = <span class="s">"Hello, "</span> + name<br>
	&nbsp;return result<br>
    <span class="k">end</span><br>
    <br>
    puts sayHello(<span class="s">"Elyane"</span>)<br>
    puts (sayHello(<span class="s">"Marianne"</span>))<br>
    puts (sayHello <span class="s">"Josianne"</span>) <span class="c"># Ruby conseille de mettre des parenthèses.</span><br>
    puts sayHello <span class="s">"Ariane"</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="c"># De même.</span><br>
</p>

<!------------------------------------------ Classes et objets ------------------------------------------------>

<h2 class="horstexte" id="oo">Classes et objets</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Nous avons vu que tout était objet dans Ruby. Et que chaque objet a un type. Le type est une définition abstraite, et les objets sont ses exemples concrets. Par exemple, vous pouvez avoir un type <span class="code">Voiture</span> et ses objets : la voiture de Paul et la voiture du Charlotte. Au niveau du type, on a défini qu'une voiture avait une couleur. Et au niveau des objets, on précisera la valeur de cette couleur : verte pour Paul et bleue pour Charlotte. Ces objets particuliers sont appelés <span class="index">instances</span> de la classe <span class="code">Voiture</span>. Cette conception des choses, Classe/Instances, s'appelle l'orienté objet ou OO. On parlera de programmation orienté objet, ou POO.</p>

<h3 id="oo1">Premiers pas dans l'orienté objet</h3>

<p>L'orienté objet implique donc deux étapes : la définition de classes, et la création d'instances de ces classes. Commençons par définir une classe, nous allons voir dans un premier temps la syntaxe complète, puis différents exemples pour l'illustrer :</p>

<p class="code">
    <span class="k">class</span> Identifier &lt; SuperClasse<br>
    &nbsp;&nbsp;instructions<br>
    <span class="k">end</span><br>
    <br>
    <span class="k">class</span> Voiture<br>
    &nbsp;&nbsp;<span class="k">def</span> initialize(c)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;@couleur = c<br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span>
</p>

<p>On a défini ici la classe Voiture par une structure qui commence par le mot clé <span class="k">class</span> suivit du nom que l'on veut donner à la classe et se termine par <span class="k">end</span>. Le nom de la classe doit commencer par une majuscule, indiquant ainsi la constance entre l'identificateur et la classe qu'il désigne. Entre, on définit la méthode <span class="code">initialize</span>. Il faut bien voir que ce qu'on définit là, si cela appartient à la classe et à ses futures instances, ne pourra être exécuté qu'au niveau des instances de classe. On remarque aussi une variable préfixée par <b>@</b>. Ce préfixe indique que c'est une variable d'instance, qui a comme portée la durée de vie de l'instance à laquelle elle appartient et est visible dans toutes ses méthodes. Une classe peut se voir comme constituer de deux parties : une partie statique qui est un regroupement de variables (ici <span class="code">@couleur</span>), appelées aussi attributs dans ce cas là, et d'une partie dynamique, les méthodes (ici <span class="code">initialize</span>). A chaque fois, on définit cela au niveau de la classe, mais c'est au niveau de l'instance que cela prend son sens.</p>

<p>Pour créer une instance, opération que l'on appelle l'<span class="index">instanciation</span>, on fera :</p>

<p class="code">
    voiture_de_paul = Voiture.new(<span class="s">"verte"</span>)<br>
    voiture_de_charlotte = Voiture.new(<span class="s">"bleue"</span>)<br>
</p>

<p>On appelle la méthode new de la classe Voiture, qui va créer une instance, et appeler dessus la méthode initialize en lui passant ses paramètres, ici une chaîne représentant la couleur de la voiture. La méthode initialize est automatiquement appelée par new, et elle est appelée un <span class="index">constructeur</span>. Elle permet d'initialiser l'instance.</p>

<p>On peut bien sûr avoir plus d'une méthode dans une classe. Ajoutons la méthode <span class="code">rouler</span> à notre classe : </p>

<p class="code">
    <span class="k">class</span> Voiture<br>
    &nbsp;&nbsp;<span class="k">def&nbsp;</span>rouler()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;puts <span class="s">'je roule'</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
</p>

<p>Pour ajouter une méthode à une classe, il suffit de réouvrir la structure <span class="k">class</span> et d'y écrire au milieu la ou les méthodes à ajouter. La méthode rouler que l'on ajoute ne prend pas d’arguments comme l'indique les parenthèses qui suivent le nom de la méthode et sont donc optionnelles. Au contraire de la méthode <span class="code">initialize</span>, qui est une méthode spéciale automatiquement appelée lors de la création d’une nouvelle instance, nous devons appeler explicitement <span class="code">rouler</span>.

<p class="code">
    voiture_de_sam = Voiture.new(<span class="s">"noire"</span>)<br>
    voiture_de_sam.rouler <span class="c"># Appel de la méthode rouler qui affiche "je roule"</span>
</p>

<p>Et maintenant, on veut ajouter un nouvel attribut à la classe <span class="code">Voiture</span>. On veut que chaque voiture est une marque. Il nous faut donc redéfinir la méthode <span class="code">initialize</span>.</p>

<p class="code">
    <span class="k">class</span> Voiture<br>
    &nbsp;&nbsp;<span class="k">def</span> initialize(c, m)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;@couleur = c<br>
    &nbsp;&nbsp;&nbsp;&nbsp;@marque = m<br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
</p>

<p>Les instances précédentes n'ont pas d'attribut <span class="code">@marque</span> puisqu'elles ont été créées avant. Il faut donc les créer à nouveau avec les marques 'Lyon' et 'CNX' :</p>

<p class="code">
    voiture_de_paul = Voiture.new(<span class="s">"verte"</span>, <span class="s">'Lyon'</span>)<br>
    voiture_de_charlotte = Voiture.new(<span class="s">"bleue"</span>, <span class="s">'CNX'</span>)<br>
</p>

<p>La méthode <span class="code">new</span> de la classe Voiture va créer deux nouvelles instances et appelera la nouvelle fonction initialize pour ces deux objets en leur passant ses paramètres. Pour voir si tout c’est bien passé, vous pouvez faire un appel à la méthode inspect :</p>

<p class="code">
    voiture_de_paul.inspect <span class="c"># Affiche @couleur="verte" @marque="Lyon"</span><br>
</p>

<h3 id="methodes3">Les méthodes dans l'OO</h3>

<p>Une méthode en Ruby appartient à un objet et ce déclare avec la syntaxe suivante :</p>
<p class="code">
    <span class="k">def&nbsp;</span>nom_methode(paramètres)<br>
    &nbsp;&nbsp;code<br>
    <span class="k">end</span><br>
</p>

<p>Nous avons vu jusqu'à présent seulement des méthodes d'instance définies à l'intérieur d'une classe. Mais on peut aussi définir une méthode pour la classe elle-même, ou bien pour une instance particulière.</p>

<h4>Méthode d'instance</h4>

<p>La définition de la méthode se fait dans la classe de l’objet. Ces méthodes sont appelées méthodes d’instances.</p>

<p class="code">
    <span class="k">class</span> Voiture<br>
    &nbsp;&nbsp;<span class="k">def</span> rouler()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;puts <span class="s">'je roule en #{@marque}'</span><br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
    <br>
    v = Voiture.new(<span class="s">"blanche"</span>, <span class="s">"CNX"</span>)<br>
    v.rouler <span class="c"># Affiche "je roule en CNX"<br>
</p>

<p>On peut remarquer au passage un moyen simple pour inclure une variable dans une chaîne : la syntaxe <span class="code">#{code}</span> permet cela.</p>

<h4>Méthode de classe</h4>

<p>On peut définir une méthode pour la classe elle-même. Il suffit de faire précéder son nom par le nom de la classe suivit d'un point dans sa définition. Ces méthodes sont appelées méthodes de classe.</p>

<p class="code">
    <span class="k">class</span> Voiture<br>
    &nbsp;&nbsp;<span class="k">def</span> Voiture.affiche_nom_classe()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;puts <span class="s">'Voiture'</span><br>
    &nbsp;&nbsp;<span class="k">end</span><br>
    <span class="k">end</span><br>
    <br>
    Voiture.affiche_nom_classe() <span class="c"># Affiche "Voiture"</span><br>
</p>

<p>Contrairement à d'autres langages, on ne peut appeler une méthode de classe que sur la classe elle-même et pas une instance de celle-ci.</p>

<h4>Méthode singleton</h4>

<p>définition de la méthode en dehors de la classe de l’objet en indiquant l’objet ainsi : def identificateur.nom_methode . Une méthode définie pour un objet particulier s’appelle une méthode singleton.</p>
<p>Exemple :</p>
<p class="code">
&nbsp;v<span class="i">1</span>&nbsp;=&nbsp;Voiture.new<br>
&nbsp;<span class="k">def&nbsp;</span>v<span class="i">1</span>.rouler_vite()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts</span>&nbsp;<span class="s">'je&nbsp;roule&nbsp;vite'</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;v<span class="i">1</span>.rouler_vite()&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;je&nbsp;roule&nbsp;vite</span><br>
&nbsp;v<span class="i">2</span>&nbsp;=&nbsp;Voiture.new<br>
&nbsp;v<span class="i">2</span>.rouler_vite()&nbsp;&nbsp;<span class="c">#&nbsp;Erreur!&nbsp;:&nbsp;rouler_vite&nbsp;n'est&nbsp;pas&nbsp;définie&nbsp;pour&nbsp;v<span class="i">2</span>&nbsp;seulement&nbsp;pour&nbsp;v<span class="i">1</span>&nbsp;!</span><br>
</p>
<p class="code">
&nbsp;aa&nbsp;=&nbsp;<span class="s">"hello"</span><br>
&nbsp;<span class="k">class&nbsp;</span><<&nbsp;aa<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>to_s<br>
		<span class="s">"The&nbsp;value&nbsp;is&nbsp;<span class="s">'<span class="c">#{self}'</span>"</span></span><br>
	&nbsp;<span class="k">end</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;puts</span>&nbsp;aa.to_s<br>
</p>
<p>Les fonctions que vous écrivez en dehors de toutes classes qui ne sont pas des méthodes pour un objet particulier sont des méthodes rattachées aux instances de la classe Object et seront appelables par tous les objets.</p>
<p>Paramètres</p>
<p>Les paramètres sont séparés par des virgules. Si il n’y pas de paramètres (), les parenthèses sont optionnelles.</p>
<p>Exemple :</p>
<p class="code">
&nbsp;<span class="k">def&nbsp;</span>pipo()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts</span>&nbsp;<span class="s">'pipo'</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;pipo()&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;pipo</span><br>
</p>
<p>Equivaut à :</p>
<p class="code">
&nbsp;<span class="k">def&nbsp;</span>pipo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts</span>&nbsp;<span class="s">'pipo'</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;pipo&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;pipo</span><br>
</p>
<p>Mais mon conseil est de toujours mettre des parenthèes. En effet, si on déclare une fonction du même nom qu’une variable, et que on ne mais pas de parenthèses, Ruby préférera croire que c’est la variable plutôt qu’un appel à une fonction !</p>
<p>Exemple :</p>
<p class="code">
&nbsp;<span class="k">def&nbsp;</span>pipo()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts</span>&nbsp;<span class="s">'pipo'</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;pipo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;pipo</span><br>
&nbsp;pipo&nbsp;=&nbsp;<span class="i">3</span>&nbsp;&nbsp;<span class="c">#&nbsp;Déclaration&nbsp;d<span class="s">'une&nbsp;variable&nbsp;entière&nbsp;de&nbsp;valeur&nbsp;<span class="i">3</span>,&nbsp;désignée&nbsp;par&nbsp;l'</span>identificateur&nbsp;pipo</span><br>
&nbsp;pipo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;<span class="i">3</span>&nbsp;#&nbsp;Ruby&nbsp;doit&nbsp;choisir&nbsp;:&nbsp;danger&nbsp;!</span><br>
&nbsp;pipo()&nbsp;&nbsp;&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;pipoVoici&nbsp;une&nbsp;fonction&nbsp;multi-paramétrées&nbsp;:</span><br>
&nbsp;<span class="k">def&nbsp;</span>affiche(nom,&nbsp;age)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;nom+&nbsp;<span class="s">"&nbsp;a&nbsp;"</span>+age.to_s+<span class="s">"&nbsp;ans"</span>&nbsp;&nbsp;<span class="c">#&nbsp;la&nbsp;méthode&nbsp;to_s&nbsp;convertit&nbsp;l'objet&nbsp;age&nbsp;en&nbsp;une&nbsp;chaîne</span><br>
&nbsp;<span class="k">end</span><br>
</p>

<h3 id="encapsulation">L’encapsulation</h3>

<p>Cela consiste à masquer des méthodes, des attributs de nos objets. En effet, pour limiter leur utilisation, ou quand leur utilisation ne regarde pas l’utilisateur de la classe mais seulement le concepteur.</p>
<h4>Encapsulation des méthodes</h4>
<p>Lors de la définition d’une classe, vous pouvez définir le niveau d’encapsulation de chaque méthode. Ainsi, le niveau d’encapsulation par défaut est ‘public’. Cela définit qu’une méthode f défini pour un objet de la classe C pourra être appelée depuis n’importe où. Le niveau ‘protected’ indique que la méthode ne pourra être appelée qu’à l’intérieur du code de la classe ou de une de ses classes filles. Le niveau ‘private’ enfin, indique la méthode ne pourra être appelée qu’à l’intérieur du code de la classe, sans indiquer de récepteur.</p>
<p>La syntaxe est la suivante :</p>
<p class="code">
&nbsp;public&nbsp;[(:symbol)]<br>
&nbsp;protected&nbsp;[(:symbol)]<br>
&nbsp;private&nbsp;[(:symbol)]<br>
</p>
<p>Si les symboles sont omis, toutes les méthodes suivantes seront à ce niveau d’encapsulation.</p>
<h4>Encapsulation des attributs</h4>
<p>En Ruby, tout attribut d’instance est par définition privé. Pour déclarer que l’on peut y accéder en lecture il faut définir une méthode d’accès en lecture grâce à la syntaxe :</p>
<p class="code">
&nbsp;attr_reader</span>&nbsp;:symbol[,:symbol]*<br>
</p>
<p>Pour déclarer qu’un attribut peut être aussi en écriture, il suffit de déclarer une méthode d’accès (ou accesseurs) en écriture :</p>
<p class="code">
&nbsp;attr_writer</span>&nbsp;:symbol[,:symbol]*<br>
</p>
<p>Pour déclarer un accesseur dans les deux sens (lecture et écriture) on peut faire :</p>
<p class="code">
&nbsp;attr_accessor</span>&nbsp;:symbol&nbsp;[,:symbol]*<br>
</p>
<p>Voici une définition UML de classe Personne :</p>
<p class="code">
&nbsp;Personne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c">#&nbsp;Nom&nbsp;de&nbsp;la&nbsp;classe</span><br>
&nbsp;-age<br>
&nbsp;+Marcher()<br>
&nbsp;+FêterAnniversaire()<br>
&nbsp;+getAge()<br>
</p>
<p>La définition correspondante en Ruby :</p>
<p class="code">
&nbsp;<span class="k">class&nbsp;</span>Personne<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>initialize()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@age&nbsp;=&nbsp;<span class="i">0</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>Marcher()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts</span>&nbsp;<span class="s">'je&nbsp;marche'</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>FêterAnniversaire()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@age&nbsp;+=&nbsp;<span class="i">1</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr_reader</span>&nbsp;:age<br>
&nbsp;<span class="k">end</span><br>
</p>
<h4>Utilisation :</h4>
<p class="code">
&nbsp;bob&nbsp;=&nbsp;Personne.new()<br>
&nbsp;puts</span>&nbsp;bob.age&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;<span class="i">0</span></span><br>
&nbsp;bob.FêterAnniversaire()<br>
&nbsp;puts</span>&nbsp;bob.age&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;<span class="i">1</span></span><br>
&nbsp;bob.Marcher()&nbsp;&nbsp;<span class="c">#&nbsp;Affiche&nbsp;:&nbsp;je&nbsp;marche</span><br>
</p>
<p>Et voilà !</p>

<!------------------------------------------ HIC SUNT DRACONES ------------------------------------------------>

<h2 class="horstexte" id="modules">Modularité</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p class="code">
&nbsp;<span class="k">module&nbsp;</span>Identifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instructions<br>
&nbsp;<span class="k">end</span><br>
</p>
<p># When you include a module, Ruby creates an anonymous proxy class that references that module, and inserts that proxy as the direct superclass of the class that  did the including. The proxy class contains references to the instance variables and methods of the module. This is important: the same module may be included in many different classes, and will appear in many different inheritance chains. However, thanks to the proxy class, there is still only one underlying module: change a method definition in that module, and it will change in all classes that include that module, both past and future. </p>
<p class="code">
&nbsp;puts<br>
&nbsp;puts</span>&nbsp;<span class="s">"Mix<span class="</span>k<span class="s">">in&nbsp;</span>and&nbsp;modules"</span><br>
&nbsp;<span class="k">module&nbsp;</span>HelloMod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="s">"Hello!"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;<span class="k">class&nbsp;</span>C<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">include&nbsp;</span>HelloMod<br>
&nbsp;<span class="k">end</span><br>
&nbsp;c&nbsp;=&nbsp;C.new<br>
&nbsp;puts</span>&nbsp;c.hello<br>
&nbsp;<span class="k">module&nbsp;</span>HelloMod<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="s">"zorbix"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;puts</span>&nbsp;c.hello<br>
</p>
<p>Extending objects</p>
<p class="code">
&nbsp;<span class="k">module&nbsp;</span>Laetitia<br>
	<span class="k">def&nbsp;</span>hello<br>
		<span class="s">"hey&nbsp;!"</span>&nbsp;<br>
	<span class="k">end</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;cc&nbsp;=&nbsp;<span class="s">"Grouchy"</span><br>
&nbsp;cc.ext<span class="k">end</span>&nbsp;Laetitia<br>
&nbsp;puts</span>&nbsp;cc.hello<br>
&nbsp;<span class="k">class&nbsp;</span>Lae&nbsp;<br>
	<span class="k">include&nbsp;</span>Laetitia	<span class="c">#&nbsp;ajoute&nbsp;comme&nbsp;méthode&nbsp;d'instance</span><br>
&nbsp;	ext<span class="k">end</span>&nbsp;Laetitia		<span class="c">#&nbsp;appel&nbsp;à&nbsp;object#ext<span class="k">end</span>,&nbsp;donc&nbsp;self.ext<span class="k">end</span>&nbsp;avec&nbsp;self&nbsp;=&nbsp;Lae&nbsp;(la&nbsp;classe)&nbsp;donc&nbsp;méthode&nbsp;de&nbsp;classe</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;lae&nbsp;=&nbsp;Lae.new<br>
&nbsp;puts</span>&nbsp;lae.hello<br>
&nbsp;puts</span>&nbsp;Lae.hello<br>
</p>

<h2 class="horstexte" id="exceptions">Gestion des exceptions</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p class="code">
&nbsp;<span class="k">begin</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instructions<br>
&nbsp;rescue&nbsp;Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instructions&nbsp;en&nbsp;cas&nbsp;d'erreur<br>
&nbsp;ensure<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instructions&nbsp;toujours&nbsp;exécutées&nbsp;à&nbsp;la&nbsp;fin<br>
&nbsp;<span class="k">end</span><br>
</p>
<p>retry</p>

<h2 class="horstexte" id="astuces">Astuces</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<h3>Appel de bibliothèque</h3>
<p class="code">
&nbsp;<span class="k">require&nbsp;</span><span class="s">'ma_bibliothèque'</span><br>
</p>
<p>Ruby cherchera alors le fichier ma_bibliothèque.rb ou .so dans les dossiers spécifiés par loadpath ainsi que le répertoire courant. On peut changer le loadpath en faisant : $LOAD_PATH &lt;&lt; 'c:/mon_dossier/'</p>
<p class="code">
&nbsp;<span class="k">require&nbsp;</span><span class="s">'gosu'</span><br>
</p>
<p>Va chercher la librairie gosu.dll. Toutes les éléments sont importées via l'espace de nom Gosu dans l'espace courant.</p>
<p>Gosu::xxx</p>
<p>Si on veut directement importer les éléments de Gosu dans l'espace de nom courant faire :</p>
<p>include Gosu</p>
<h3>Expression régulière</h3>
<p class="code">
&nbsp;regexp&nbsp;=~&nbsp;string<br>
</p>
<p>Compare une expression à une chaîne, retourne un nombre (l'emplacement du début de la partie associée) si il y a association. Sinon nil. </p>
<p>Littéral /chaîne/ %r{chaîne} </p>
<p>Symboles spéciaux : </p>
<ul><li> ^ début (à gauche) </li>
<li> $ fin (à droite) </li>
<li> . n'importe quel caractère</li>
<li> [a-z] groupe (de a à z)</li>
<li> /pattern/</li>
<li> | ou</li>
<li> ( ) priorité</li>
<li> + 1 ou +</li>
<li> * 0 ou +</li>
<li> ? 0 ou 1</li>
<li> \s space, tab, newline, etc.</li>
<li> \d digit</li>
<li> \w any character that may appear in a typical word</li>
</ul>
<p class="code">
&nbsp;text&nbsp;=&nbsp;<span class="s">"La&nbsp;lune&nbsp;est&nbsp;une&nbsp;dure&nbsp;maîtresse&nbsp;-&nbsp;Pour&nbsp;qui&nbsp;sonne&nbsp;le&nbsp;glas&nbsp;-&nbsp;Heart&nbsp;of&nbsp;Darkness"</span><br>
&nbsp;<span class="k">if&nbsp;</span>/lune|glas/&nbsp;=~&nbsp;text&nbsp;<span class="k">then&nbsp;</span>puts</span>&nbsp;<span class="s">"glaslune&nbsp;!"</span>&nbsp;<span class="k">end</span><br>
&nbsp;text.sub!(/lune/,&nbsp;<span class="s">'moon&nbsp;of&nbsp;mars'</span>)&nbsp;<span class="c">#&nbsp;<span class="i">1</span>ère&nbsp;occurence</span><br>
&nbsp;text.gsub!(/of/,&nbsp;<span class="s">'de'</span>)&nbsp;<span class="c">#&nbsp;toutes&nbsp;les&nbsp;occurences</span><br>
&nbsp;puts</span>&nbsp;text<br>
</p>
<h3>Substitution d'expression</h3>
<p class="code">
&nbsp;name&nbsp;=&nbsp;<span class="s">"Adrien"</span><br>
&nbsp;puts</span>&nbsp;<span class="s">"Mon&nbsp;nom&nbsp;est&nbsp;<span class="c">#{name}"</span></span><br>
&nbsp;puts</span>&nbsp;<span class="s">"<span class="i">4</span>+<span class="i">4</span>&nbsp;=&nbsp;<span class="c">#{<span class="i">4</span>+<span class="i">4</span>}"</span></span><br>
</p>

<h2 class="horstexte" id="bibliotheques">Bibliothèques</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<p>Sites de bibliothèques : <a class="intext" href="http://raa.ruby-lang.org/""> RAA</a> (comme CPAN, Pear, Pecl pour Perl), [[href="http://rubyforge.org/", RubyForge]]</p>
<p class="code">
&nbsp;rand(max)&nbsp;de&nbsp;<span class="i">0</span>&nbsp;à&nbsp;max<br>
&nbsp;puts</span>&nbsp;something<br>
&nbsp;something&nbsp;=&nbsp;gets<br>
</p>
<h3>Watir</h3>
<p><a class="intext" href=""http://wiki.openqa.org/display/WTR/Example+Test+Case""> lien</a></p>
<p>Watir est un module de test d'application web avec IE pour Ruby. Des versions .Net (Watin) et Java (Watij) existe aussi. Le but est d'automatiser le comportement du navigateur internet en vue de tester l'application.</p>
<p class="code">
&nbsp;<span class="k">require&nbsp;</span><span class="s">"watir"</span><br>
&nbsp;test_site&nbsp;=&nbsp;<span class="s">"http://www.google.com"</span><br>
&nbsp;ie&nbsp;=&nbsp;Watir::IE.new<br>
&nbsp;ie.goto&nbsp;test_site<br>
&nbsp;ie.text_field(:name,&nbsp;<span class="s">"q"</span>).set&nbsp;<span class="s">"pickaxe"</span><br>
&nbsp;ie.button(:name,&nbsp;<span class="s">"btnG"</span>).click<br>
&nbsp;ie.text.include?&nbsp;<span class="s">"Programming&nbsp;Ruby"</span><br>
</p>
<h3>Gosu</h3>
<p>La classe principale de notre application est une fenêtre.</p>
<p class="code">
&nbsp;<span class="k">class&nbsp;</span>Fenêtre&nbsp;&lt;&nbsp;Gosu::Window<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>initialize<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(largeur,&nbsp;hauteur,&nbsp;booléen)&nbsp;&lt;?&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.caption&nbsp;=&nbsp;<span class="s">"Titre"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialisation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>update<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>draw<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">def&nbsp;</span>button_down(id)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">end</span><br>
&nbsp;<span class="k">end</span><br>
&nbsp;f&nbsp;=&nbsp;Fenêtre.new<br>
&nbsp;f.show<br>
</p>
<p>Gosu::Button::xxx</p>
<p>Enumération de tous les boutons possibles.</p>

<h2 class="horstexte" id="biblio">Bibliographie</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<ul>
  <li>Alexandre Brillant, Ruby, les fondamentaux du langage, ENI éditions, collection Ressources Informatiques, 2008, France.</li>
  <li>Yukihiro Matsumoto, Eric Jacoboni (trad.), Ruby In A Nutshell, O'Reilly éditions, 2002, France.</li>
</ul>

<h2 class="horstexte" id="liens">Liens</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<ul>
  <li><a class="intext" href="http://wiki.openqa.org/display/WTR/Ruby+Cheat+Sheet""> Aide mémoire de Watir sur Ruby</a></li>
  <li><a class="intext" href="http://code.google.com/p/gosu-fr/wiki/TutorielRubyGosu""> Tutoriel Gosu</a></li>
  <li><a class="intext" href="http://www.rubyfrance.org/""> Association RubyFrance</a></li>
  <li><a class="intext" href="http://www.rubycentral.org/""> Association RubyCentral</a></li>
  <li><a class="intext" href="http://fr.wikipedia.org/wiki/Ruby"> Page Wikipedia (français)</a></li>
  <li><a class="intext" href="http://en.wikipedia.org/wiki/Ruby_(programming_language)"> Page Wikipedia (anglais, plus complète)</a></li>
  <li><a class="intext" href="http://www.ruby-doc.org/"> Toute la documentation Ruby</a></li>
  <li><a class="intext" href="http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html"> Manuel de la version 1.4</a></li>
</ul>

<h2 class="horstexte" id="resume">Résumé</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<h2 class="horstexte" id="index">Index</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<dl>
  <dt>affectation par copie de la valeur 
    <dd>aff_copie_valeur
  <dt>affectation par copie de la référence
    <dd>aff_copie_ref
  <dt>caractères d'échappement
    <dd>car_echap
  <dt>pseudo variable
    <dd>pseudo_var
</dl>

<h2 class="horstexte" id="historique">Historique du document</h2>
<a href="#sommaire"><i>(retour sommaire)</i></a>

<ul>
  <li>Samedi 7 Avril
    <ul>
      <li>Version Alpha 01.</li>
      <li>Mise en ligne sur ran.</li>
    </ul>
  </li>
  <li>Dimanche 8 Avril
    <ul>
       <li>Version Alpha 02.</li>
       <li>première partie OK.</li>
    </ul>
  </li>
  <li>Mercredi 11 Avril
    <ul>
      <li>Version Alpha 03.</li>
      <li>division en grandes parties.</li>
      <li>seconde partie - les opérateurs OK.</li>
    </ul>
  </li>
  <li>Jeudi 12 Avril
    <ul>
      <li>Version Alpha 04.</li>
      <li>ajout référence Ruby in a nutshell.</li>
      <li>seconde partie - contrôle du flux OK.</li>
      <li>seconde partie - méthodes OK.</li>
    </ul>
  </li>
  <li>Vendredi 13 Avril
    <ul>
      <li></li>
    </ul>
  </li>
</ul>

                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </body>
    </html>	
