<html>
    <head>
        <meta charset="utf-8">
        <title>TED5 viewer</title>
        <style>
            h1 {
                width: 100%;
                text-align: center;
            }
            pre {
                border: 1px solid #ACAEB0;
                background-color: #f5f5f5;
                padding: 1rem;
            }
            table {
                border-collapse: collapse;
            }
            td {
                border: 1px solid black;
            }
        </style>
        <script>
            // https://moddingwiki.shikadi.net/wiki/GameMaps_Format

            function hex(v)
            {
                return '0x' + v.toString(16).padStart(8, '0') + ' (' + v + ')';
            }

            class Header
            {
                constructor(data)
                {
                    this.total_nb_bytes = data.byteLength; // 402
                    this.nb_bytes = 0;
                    this.magic = new Uint16Array(data.slice(0, 2))[0]; // 43981 12h14
                    this.nb_bytes += 2;
                    this.ptr = [];
                    for (let i = 0; i < 100; i++)
                    {
                        let p = new Uint32Array(data.slice(2 + i * 4, 2 + (i+1) * 4))[0];
                        this.nb_bytes += 4;
                        if (p == 0xffffffff) // Avant on continuait jusqu'au max, 100 !
                        {
                            break;
                        }
                        this.ptr.push(p);
                    }
                }

                toString()
                {
                    let s = `Magix hex = ${hex(this.magic)} dec = ${this.magic}\n`;
                    s += `Number of bytes read = ${this.nb_bytes} / ${this.total_nb_bytes}\n`;
                    s += `Number of levels = ${this.ptr.length}\n`;
                    for (let i = 0; i < this.ptr.length; i++)
                    {
                        s += `    - Lvl ${(i+1).toString().padStart(2, ' ')} start at ${hex(this.ptr[i])}\n`
                    }
                    return s;
                }
            }

            class Plane
            {
                constructor(start, length, content)
                {
                    this.start = start;
                    this.length = length;
                    this.content = content;
                }
            }

            class Level
            {
                constructor()
                {
                    this.planes = [];
                }

                toString()
                {
                    let s = "[Starts]            : " + this.planes[0].start + ", " + this.planes[1].start + ", " + this.planes[2].start + "\n" +
                            "[CompressedLenghts] : " + this.planes[0].length + ", " + this.planes[1].length + ", " + this.planes[2].length + "\n" +
                            "[ReadLengths]       : " + this.planes[0].content.length + ", " + this.planes[1].content.length + ", " + this.planes[2].content.length + "\n" +
                            "[Sizes]             : " + this.width + "x" + this.length + " (" + (64 * 64) + ")\n" +
                            "[Name]              : " + this.name;
                    return s;
                }
            }

            class LevelSet
            {
                constructor(data, header)
                {
                    this.header = header;
                    let dec = new TextDecoder();
                    this.format = dec.decode(data.slice(0, 8));
                    this.levels = [];
                    for (let i of this.header.ptr)
                    {
                        console.log(`Reading ${i}`);
                        this.levels.push(this.read_level(data, i, this.header.magic));
                    }
                    if (this.levels.length > 0)
                    {
                        let lvl = this.levels[this.levels.length - 1];
                        let end = lvl.startPlane2 + lvl.lengthPlane2;
                        console.log(">>>>>>> " + end);
                        console.log(">>>>>>> " + data.byteLength);
                        if (end < data.byteLength)
                        {
                            this.ending = dec.decode(data.slice(end, data.byteLength));
                        }
                    }
                }

                read_level(data, startLevel, magic)
                {
                    let level = new Level();
                    let startPlane0 = new Uint32Array(data.slice(startLevel, startLevel + 4))[0];
                    let startPlane1 = new Uint32Array(data.slice(startLevel + 4, startLevel + 8))[0];
                    let startPlane2 = new Uint32Array(data.slice(startLevel + 8, startLevel + 12))[0];
                    let lengthPlane0 = new Uint16Array(data.slice(startLevel + 12, startLevel + 14))[0];
                    let lengthPlane1 = new Uint16Array(data.slice(startLevel + 14, startLevel + 16))[0];
                    let lengthPlane2 = new Uint16Array(data.slice(startLevel + 16, startLevel + 18))[0];
                    level.width = new Uint16Array(data.slice(startLevel + 18, startLevel + 20))[0];
                    level.length = new Uint16Array(data.slice(startLevel + 20, startLevel + 22))[0];
                    let dec = new TextDecoder();
                    level.name = dec.decode(data.slice(startLevel + 22, startLevel + 32));
                    let plane0 = this.rwle_expand(magic, data.slice(startPlane0, startPlane0 + lengthPlane0));
                    let plane1 = this.rwle_expand(magic, data.slice(startPlane1, startPlane1 + lengthPlane1));
                    let plane2 = this.rwle_expand(magic, data.slice(startPlane2, startPlane2 + lengthPlane2));
                    level.planes.push(new Plane(startPlane0, lengthPlane0, plane0));
                    level.planes.push(new Plane(startPlane1, lengthPlane1, plane1));
                    level.planes.push(new Plane(startPlane2, lengthPlane2, plane2));
                    return level;
                }

                rwle_expand(magic, data)
                {
                    let size = new Uint16Array(data.slice(0, 2))[0];
                    console.log("RWLE EXPAND SIZE = " + size);
                    let expanded = [];
                    let i = 2;
                    while (i < data.byteLength)
                    {
                        let v = new Uint16Array(data.slice(i, i+2))[0];
                        i += 2
                        if (v == magic)
                        {
                            let count = new Uint16Array(data.slice(i, i+2))[0];
                            i += 2
                            let value = new Uint16Array(data.slice(i, i+2))[0];
                            i += 2
                            expanded = expanded.concat(Array(count).fill(value));
                        } else {
                            expanded.push(v);
                        }
                    }
                    return expanded;
                }

                toString()
                {
                    let s = "Format: " + this.format + "\n";
                    let nb = 0;
                    for (let i of Object.values(this.levels))
                    {
                        s += `[Level ${nb}]\n` + i.toString() + "\n";
                        nb += 1;
                    }
                    s += "Ending: " + this.ending + "\n";
                    return s;
                }
            }

            function createTable(set, ilevel, iplane)
            {
                let info = document.createElement("h2");
                info.innerText = set.levels[ilevel].name + " num " + ilevel + " plane " + iplane;
                document.getElementById("result").appendChild(info);
                let table = document.createElement("table");
                let plane = set.levels[ilevel].planes[iplane];
                let row_length = set.levels[ilevel].width;
                let row = document.createElement("tr");
                let cell = document.createElement("td");
                let nb_lines = 0;
                cell.innerHTML = `<b>${nb_lines}</b>`;
                row.appendChild(cell);
                console.log("level.length = " + plane.content.length);
                let images = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 90, 91];
                for (let nb = 0; nb < plane.content.length; nb++)
                {
                    cell = document.createElement("td");
                    let val = plane.content[nb];
                    console.log(val, typeof(val));
                    if (images.includes(val))
                    {
                        let img = document.createElement("img");
                        img.src = "" + val + "b.png"; // 5 = #0000084 avec un carré de 56 au milieu, 8 = #000084, 9 = #00000056
                        img.style.width = "32px";
                        img.style.height = "32px";
                        cell.style.padding = "0px";
                        cell.appendChild(img);
                    }
                    else if (val < 100)
                    {
                        cell.innerText = val;
                    }
                    row.appendChild(cell);
                    row_length -= 1;
                    if (row_length == 0)
                    {
                        nb_lines += 1;
                        table.appendChild(row);
                        row = document.createElement("tr");
                        row_length = set.levels[ilevel].width;
                        cell = document.createElement("td");
                        cell.innerHTML = `<b>${nb_lines}</b>`;
                        row.appendChild(cell);
                    }
                }
                document.getElementById("result").appendChild(table);
            }

            var handler = null;

            function handleFiles(files ,type)
            {
                if (files.length > 0)
                {
                    let file = files[0];
                    let reader = new FileReader();
                    reader.onloadend =
                        function(event)
                        {
                            let console2 = document.getElementById("console");
                            if (type === 'header')
                            {
                                handler = new Header(event.target.result);
                                console2.innerText = handler.toString();
                            } else {
                                if (handler == null)
                                {
                                    alert("Set a map header file first!");
                                    return;
                                }
                                let set = new LevelSet(event.target.result, handler);
                                let old = console2.innerText;
                                console2.innerText = old + set.toString();

                                createTable(set, 0, 0);
                                createTable(set, 0, 1);
                                createTable(set, 0, 2);
                            }
                        }
                    ;
                    reader.readAsArrayBuffer(file);
                    //reader.readAsBinaryString(file);
                }
            }
        </script>
    </head>
    <body>
        <h1>TED5 viewer</h1>
        <fieldset style="display: flex;">
            <legend>Fichiers</legend>
            <label for="fileInput1">En-têtes :</label> <input type="file" id="fileInput1" onchange="handleFiles(this.files, 'header')">
            <label for="fileInput2">Contenus :</label> <input type="file" id="fileInput2" onchange="handleFiles(this.files, 'content')">
        </fieldset>
        <pre id="console">
        </pre>
        <div id="result">
        </div>
    </body>
</html>