Ce document décrit le langage Ash, une syntaxe alternative pour Python.

Ce document décrit un langage minimaliste de script.
On décrit des EXTENSION (EXT) et des ALTERNATIVES (ALT) possibles.

Ce langage est très inspiré de :
    1) Lua
    2) Ruby
    3) Pascal

Il se veut simple et pérenne (pas de multiples versions tous les ans).

Lua est une bonne base, par son petit périmète, mais souffre de plusieurs défauts selon moi :
    o l'opérateur de différence est ~= au lieu du standard !=
    o la fusion des listes et des dictionnaires dans les tables est imbitables
    o par exemple, impossible d'avoir un compte fiable d'une table avec l'opérateur # si on mixe index numérique et non numérique
    o impossible de savoir si une clé est définie ou contient nil
    o présence de goto, my goodness!
    o pas de continue ou de next dans les boucles
    o pas de vérification du nombre de paramètres (la valence) des fonctions
    o bien sûr, aucune vérification possible du type des paramètres (mais Teal, un langage dérivé, le peut)
    o pas d'opérateurs combinés comme +=
    o la bibliothèque standard est ultralimité, il faudrait penlib directement dedans
    o pas d'orienté objet de base (encapsulation et héritage)
    o break et return ne peuvent apparaître que comme dernier statement d'un bloc
      https://www.lua.org/pil/4.4.html
    o pas d'exceptions, seulement pcall, error, xpcall, pas de try/catch/raise/throw/finally
    o il faut mettre entre crochets la clé si ce n'est pas un symbole : { ["a"] = 5 }
    o un test de if/while ne devrait se faire que sur des booléens
Il y a des points positifs néanmoins :
    o les listes vides, le nombre 0 et une liste vide sont vrais seuls false et nil sont faux
      http://t-a-w.blogspot.com/2007/07/truth-falsehood-and-voidness-in-dynamic.html
    o 8 types de base only : nil, boolean, number, string, function, thread, table, and userdata
    o possible de retourner plusieurs valeurs http://www.lua.org/pil/5.1.html
      mais attention (f()) fait ne retourner qu'une valeur
    o possibilité de faire des labels bon ça marche avec des goto par contre :(
      http://lua-users.org/wiki/GotoStatement

1. Bases
========

1.A Commentaires
----------------

Les commentaires commençent par "--".
Cela permet de conserver "//" et "#" comme opérateurs de intdiv et longueur.
Pas de commentaires multilignes. On fera un "return" pour éviter du code.

EXT : "--[[ ]]" pour les multilignes.
ALT : "/*" et "*/" mais ce n'est plus raccord avec "--".

1.B Encodage et case-sensitive
------------------------------

Tout est case-sensitive. Ab != Ba
Le style est :
    - a_b pour les méthodes, les attributs et les variables.
    - Ab pour les classes et les constantes
Les fichiers sont encodés en ASCII.

1.C Mots clés
-------------

27 en tout.
const, var, if, then, elif, else, end, while, do, for, in, break, next, and, or, not, fun, pro, function, procedure, return, self, super, nil, false, true, require

Délimiteurs : ( ) [ ] { } ; ,

ALT : remove const, var => 25

2. Types de base
================

- 1, 0b0101, 0xAF00, 0c10 => int pour les entiers
- 1.2 => float/flt pour les flottants
- true/false => bool pour les booléens
- " ", ' ' => string/str pour les chaînes
- [1, 2] => list pour les listes/array/tableaux
- {k = v} => hash pour les dictionnaires/tables de hashage ( = : veut dire associer)

On garde : pour le typage et => pour autre chose.

Les noms des types doivent être courts car on les écrira souvent.

ALT : => pour les dico
ALT : number pour les float (num)
ALT : [ k = v ] pour les dico, on garde { } seulement pour les blocks en rempla de then/do/end
ALT : on supprime les octaux
ALT : on autorise \n dans une chaîne et on supprime ' '

3. Variables et constantes
==========================

[const | var] ID [: TYPE] = EXPRESSION
const A = 5
a : int = 5

: TYPE disent que c'est une constance de type.
const dit que c'est une constance de valeur.
nil permet de mettre une variable à "non initialisée".
Tous les types s'entendent comme int ou nil (non initialisée).
Une variable à nil ne peut être testée que pour is nil/is not nil

EXT : := pour une constance de type avec type inféré : a := 5
    Finalement, je ne mets pas cette façon car :
    1) cela créé un pb avec const : const A = 5 n'a pas de sens, il faudrait toujours écrire const A := 5
    2) si EXPR n'est pas évident (= f()) il faut chercher le type de retour de f
ALT : on ne type pas les variables
EXT : le type "any"
ALT : ni var, ni const, on ne fait qu'à la majuscule en début d'identifiant
ALT : type? pour pouvoir dire nullable
ALT : [X] pour indiquer que c'est un tableau de longueur X ou dyn pour dynamique : int[dyn] ou list(int, dyn)
ALT : comment gérer le typage des list et des hashs ? int[50] ou [int, 50] ou list(int, 50) ? str=int[50]
      ou [int=str, 50] raccourci pour Hash(int, str, 50)

4. Contrôle du flux
===================

4.A Structures de base
----------------------

instruction1
instruction2

instruction1 ; instruction2

if COND then
    ACT
elif COND then
    ACT
else
    ACT
end

[label] while COND do
    ACT
end

[label] for ID[: typ1][, ID2[: typ2]] in ID3 do
    ACT
end

On n'oblige pas dans le for à mettre var.

On peut "étiquetter" une boucle pour ensuite breaké ou nexté celle-ci.
Un label est défini ainsi :label:
:innerloop: for x in l do (comme Lua, JavaScript et C utilisent innerloop:)
ou ainsi <label>

EXT :   repeat
            ACT
        until COND
ALT : begin/end
ALT : else if, elseif, elsif
EXT : switch : switch / case / default / break ou case / when / others / break
EXT : redo, retry dans les boucles
EXT : one liner : ... if COND ou if COND => ... avec else possible et while COND =>
EXT : case expr when expr [then] ... else ... end
EXT : do ... next cond

4.B Modificateurs
-----------------

break [label]
next [label]

5. Opérateurs
=============

Mathématiques           + - * / ** // %
Booléens et binaires    and or xor not
Binaires                << >>
Comparaison             == != < <= >= >
Objet                   is in $ (conv en string/str) # (conv en int length/len/trunc) .
Range                   ..
Assignation             = += -= *= /= **= //= %= and= or= xor= not= <<= >>=

Les chaînes d'affilées se concatènent automatiquement, comme en Ruby.

EXT : ~= pour les matchs et <=> pour comparer en -1, 0, 1
EXT : ..< pour les ranges où le dernier élément n'est pas inclus
ALT : [deb..fin] ou [deb..fin[
EXT : &a permet de faire des alias a = &b a et b poitent sur la même valeur
ALT : tester nil avec ==
ALT : Définir l'interrogation de définition : defined? (en méthode) non car on veut savoir si une var existe, il faut un keyword ??? ou ?

6. Fonctions
============

6.A Déclaration
---------------

fun[ction] [id] (a : typ, b : typ -> typ[, typ]*)
pro[cedure] [id] (a : typ, b : typ)
sig[nature] [id] (a : typ, b : typ -> (typ[, typ]*) | nil)
call without parameter id
return [expr]

Autoriser ? (pour -> bool) et ! (pour modif internes) dans les id de fun/pro.

PB : fun id ( -> str) c'est laid non ?

ALT : fun id (...) : typ
ALT : func et proc et pas sub, def

6.B Appel
---------

Définition et appel universels
universal function call : f(a, b) est équivalent à a.f(b)

Un appel de fonction peut se passer de paramètre et de parenthèses, mais dans ce cas-là, au niveau du parser, c'est juste un appel à un id. C'est au niveau de l'analyzer qu'il réinterprétera cette id en fonction du contexte déclaré.

Mouais, le non parenthésage obligatoire est élégant (pour les DSL) mais compliqué.

Il y a aussi les *id (liste de param) **id (hash de param)
Ce qu'on peut faire avec les id n'est pas spécifié dans cette grammaire : $id (globale, les const le sont auto), , .

ALT : forcer le ()
ALT : doit on avoir des fonctions first class object ? Sans () obligatoire, il faut passer par &f
ALT : is après ) si on a pas de paramètres et qu'on autorise de ne pas mettre ()

7. Classes
==========

class ID [< SUPER]
end

init : fonction de constructeur (au lieu de constructor, initialize, __init__)
@attr doivent être déclaré uniquement dans init

self
super

ALT : this
EXT : enum < type is ... end
ALT : +id -id #id respectivement une clé publique, privée, et protégée mais-@a c'est laid.
EXT : type/data ID is ... end

8. Exceptions
=============

raise EXPR

try
    ACT
catch ID: typ
    ACT
finally
    ACT
end
raise expr

No redo nor retry

ALT : pas de gestion d'exceptions, on fait "à la C".
Chaque type s'entend comme pouvant accueillir les valeurs nil et error.

a = f()
if a is not nil and a is not error then
elif a is nil
elif a is error
end

ALT : when au lieu de catch (pratique car on réutilise le when du switch)
ALT : throw au lieu de raise
ALT : else s'il n'y a pas eu d'exception

9. Modules
==========

Un fichier = un module

Pour l'importer : require str ex :
    - require "flat.ash"
    - require "../flat.ash"

ALT : module ID/end
ALT : require or import ID
ALT : include or use ID
ALT : import au lieu de require. import STRING ou import :label:
      pb : import a où a est une variable...

10. Bibliothèque standard
=========================

I/O
    writeln
    write
    ALT : print, println, puts
Object
    o.clone
    o.methods
    o.respond_to?
    o.dump
    o.load
List
    l.flatten
    l.pop/shift
    l.push_front/back
    l.insert
    l.add / append
    l.first
    l.last a[-1]
    l.find
    l.find_all
    l.include?
    l.min
    l.max
    l.length/count
    l.sort
    l.reverse
    l.uniq
Hash
    d.delete
    d.find
    d.keys
    d.values

11. Syntaxe BNF
===============

11.A Légende
------------

    EXPRESSION : règle
    fun : token
    --> : transcription de règle
    { ... } : 0 à n
    [ ... ] : 0 ou 1
    | : ou
    # : commentaire
    'x' : littéral (symbole directement)

11.B Syntaxe
------------

ATTENTION : pas mis à jour avec les dernières modifications

    PROGRAM --> STATEMENT { ';' STATEMENT }

    STATEMENT -->
        | BLOCK_STATEMENT
        # Declaration (first level statement)
        | module id is MOD_BODY end
        | require string
        # Declaration (common to 1st level and module)
        | FUN_CONST_ENUM

    FUN_CONST_ENUM -->
        | fun id [ '(' [ LIST_PARAM ] ')' ] [ : id ] ( is | \n ) FUNC_BODY end
        | sub id [ '(' [ LIST_PARAM ] ')' ] ( is | \n ) SUB_BODY end
        | const id '=' EXPRESSION # var are defined in BLOCK_STATEMENT
        | enum id [ : id ] ( is | \n ) LIST_VAL_ENUM end

    LIST_EXPRESSION --> EXPRESSION { ',' LIST_EXPRESSION }

    LIST_ID --> id { ',' LIST_ID }

    LIST_ID_TYP --> id [ : id ]  { ',' LIST_ID }

    LIST_VAL_ENUM --> id [ = expression ] { ( ',' | \n ) LIST_VAL_ENUM }

    LIST_PARAM --> id [ : id ] { ',' LIST_PARAM }

    EXPRESSION -->
        | nil
        | byte
        | true
        | false
        | integer / int
        | float   / num
        | string  / str
        | LIST
        | HASH
        | LAMBDA
        | id
        | EXPRESSION BIN_OP EXPRESSION
        | UNA_OP EXPRESSION
        | FUNC_SUB_CALL
        | '(' EXPRESSION ')'

    BLOCK --> BLOCK_STATEMENT { ';' BLOCK_STATEMENT }

    BLOCK_STATEMENT --> ';'
        # Base
        | EXPRESSION
        # Declaration
        | [ var | final ] LIST_ID_TYP = LIST_EXPRESSION # final pour not override et no subclass plutôt que const
        # Selection
        | if EXPRESSION ( then | \n ) BLOCK { elseif EXPRESSION then BLOCK } [ else BLOCK ] end[if]
        # Loop
        | [<label>] while EXPRESSION ( do | \n ) BLOCK end
        | [<label>] loop ( do | \n ) BLOCK until EXPRESSION [ end[loop] | \n ]
        | [<label>] for id = EXPRESSION ',' EXPRESSION [ ',' EXPRESSION ] ( do | \n ) BLOCK end
        | [<label>] for LIST_ID in LIST_EXPRESSION ( do | \n ) BLOCK end
        # Loop special
        | break [<label>]
        | next [<label>]
        # Exception
        | try [\n] BLOCK { catch [id : ] id BLOCK } [ finally BLOCK ] end
        | throw expression

    FUNC_BODY --> FUNC_STATEMENT { ';' FUNC_STATEMENT }

    FUNC_STATEMENT -->
        BLOCK_STATEMENT
        # Function special
        | return [ LIST_EXPRESSION ]

    SUB_BODY --> SUB_STATEMENT { ';' SUB_STATEMENT }

    SUB_STATEMENT -->
        BLOCK_STATEMENT
        # Subprogram special
        | return

    MOD_BODY --> MOD_STATEMENT { ';' MOD_STATEMENT }

    MOD_STATEMENT -->
        | BLOCK_STATEMENT
        | FUN_CONST_ENUM

    LAMBDA -->
        | fun [ '(' LIST_PARAM ')' ] [ : id ] ( is | \n ) FUNC_STATEMENT end
        | sub [ '(' LIST_PARAM ')' ] ( is | \n ) SUB_STATEMENT end

    LIST --> '[' [ LIST_EXPRESSION ] [ ',' ] ']'

    HASH --> '{' [ LIST_KEY_VALUE ] [ ',' ] '}'

    LIST_KEY_VALUE --> KEY ':' EXPRESSION { ',' LIST_KEY_VALUE }

    KEY -->
        | byte
        | true
        | false
        | integer
        | float
        | string
        | id

    BIN_OP -->
        | '+' | '-' | '*' | '/' | '//' | '**' | '%'
        | '>>' | '<<'
        | '<' | '<=' | '>' | '>=' | '==' | '!='
        | and | or | xor
        | in | not in

    UNA_OP -->
        | '-'
        | not

    FUNC_SUB_CALL --> id ( LIST_EXPRESSION )

11.C Définition des tokens
--------------------------

    fun --> 'fun' 'function'
    pro --> 'pro' 'procedure'
    is --> 'is'
    end --> 'end'
    var --> 'var'
    const --> 'const'

Not used :
    enum --> 'enum'

    id --> ($ | + | # | - | @)?[a-zA-Z][a-zA-Z0-9_]*
    true --> 'true'
    false --> 'false'
    integer --> ( [0-9][0-9]* | [0-9][0-9]?[0-9]?( [0-9][0-9][0-9])*
    float --> [0-9][0-9]*.[0-9]*
    string --> "*" '*'
    if --> 'if'
    then --> 'then'
    elif --> 'elif'
    else --> 'else'
    while --> 'while'
    do --> 'do'

Not used :
    repeat --> 'repeat'
    until --> 'until'

    for --> 'for'
    break --> 'break'
    next --> 'next'
    return --> 'return'
    and --> 'and'
    or --> 'or'
    not --> 'not'

Not used :
    module --> 'module'

    require --> 'require'

Not used :
    sub --> 'sub'
    try --> 'try'
    catch --> 'catch'
    finally --> 'finally'
    throw --> 'throw'

12. Exemples / Ash en Action
----------------------------

ATTENTION : pas mis à jour avec les dernières modifications

const Personne = {
    age = 5,
    birthday = fun is @age = @age + 1 end,
}
var p = Personne.new() # alias sur clone
p.birthday
writeln(p.age) # 6

13. Nodes
---------

8 octobre 2020 :

binop (Operand, Operator, Operand)
unaop (Node, Operand)
list (Node*)
if (Condition, Action, Else)
while (Condition, Action)
for (VarList, ExprList, Action)
break (label)
next (label)
return (ExprList)
fun (ParList, OutList, Action)
pro (ParList, Action)
assign (IdList, Operator, ExprList)
parameter (identifier, type, litt)
raise (Expr)
try (Action, whenList, finalAction)
whenList (identifier, type, action)
