-------------------------------------------------------------------------------
- Légende
-------------------------------------------------------------------------------

    EXPRESSION : règle
    fun : token
    --> : transcription de règle
    { ... } : 0 à n
    [ ... ] : 0 ou 1
    | : ou
    # : commentaire
    'x' : littéral (symbole directement)
    
-------------------------------------------------------------------------------  
- Grammaire
-------------------------------------------------------------------------------

    PROGRAM --> STATEMENT { ';' STATEMENT }
    
	STATEMENT --> 
        | BLOCK_STATEMENT
        # Declaration (first level statement)
        | module id is MOD_BODY end
        | require string
        # Declaration (common to 1st level and module)
        | FUN_CONST_ENUM
        
    FUN_CONST_ENUM -->
		| fun id [ '(' [ LIST_PARAM ] ')' ] [ : id ] is FUNC_BODY end
        | sub id [ '(' [ LIST_PARAM ] ')' ] is SUB_BODY end
        | const id '=' EXPRESSION # var are defined in BLOCK_STATEMENT
        | enum id is LIST_ID end
        
    LIST_EXPRESSION --> EXPRESSION { ',' LIST_EXPRESSION }
    
    LIST_ID --> id { ',' LIST_ID }
    
    LIST_ID_TYP --> id [ : id ]  { ',' LIST_ID }
    
    LIST_PARAM --> id [ : id ] { ',' LIST_PARAM }
    
    EXPRESSION --> 
        | nil
        | true
        | false
        | integer
        | float
        | string
        | LIST
        | HASH
        | LAMBDA
        | id
        | EXPRESSION BIN_OP EXPRESSION
        | UNA_OP EXPRESSION
        | FUNC_SUB_CALL
        | '(' EXPRESSION ')'
    
    BLOCK --> BLOCK_STATEMENT { ';' BLOCK_STATEMENT }
    
    BLOCK_STATEMENT --> ';'
        # Base
        | LIST_ID = LIST_EXPRESSION
		| EXPRESSION
		# Selection
		| if EXPRESSION then BLOCK { elseif EXPRESSION then BLOCK } [ else BLOCK ] end
        # Loop
        | while EXPRESSION do BLOCK end
		| repeat BLOCK until EXPRESSION
		| for id = EXPRESSION ',' EXPRESSION [ ',' EXPRESSION ] do BLOCK end
		| for LIST_ID in LIST_EXPRESSION do BLOCK end
        # Loop special
        | break
        | next
        # Declaration
        | var LIST_ID_TYP = LIST_EXPRESSION
        
    FUNC_BODY --> FUNC_STATEMENT { ';' FUNC_STATEMENT }
    
    FUNC_STATEMENT -->
        BLOCK_STATEMENT
        # Function special
        | return [ LIST_EXPRESSION ]
    
    SUB_BODY --> SUB_STATEMENT { ';' SUB_STATEMENT }
    
    SUB_STATEMENT -->
        BLOCK_STATEMENT
        # Subprogram special
        | return
    
    MOD_BODY --> MOD_STATEMENT { ';' MOD_STATEMENT }
    
    MOD_STATEMENT -->
        | BLOCK_STATEMENT
        | FUN_CONST_ENUM
        
    LAMBDA --> 
        | fun [ '(' LIST_PARAM ')' ] [ : id ] is FUNC_STATEMENT end
        | sub [ '(' LIST_PARAM ')' ] is SUB_STATEMENT end
    
    LIST --> '[' [ LIST_EXPRESSION ] [ ',' ] ']'
    
    HASH --> '{' [ LIST_KEY_VALUE ] [ ',' ] '}'
    
    LIST_KEY_VALUE --> KEY ':' EXPRESSION { ',' LIST_KEY_VALUE }
    
    KEY --> 
        | true
        | false
        | integer
        | float
        | string
        | id
        
	BIN_OP --> 
        | '+' | '-' | '*' | '/' | '//' | '**' | '%'
		| '&' | '~' | '|' | '>>' | '<<'
		| '<' | '<=' | '>' | '>=' | '==' | '!='
		| and | or
        | in | not in
    
    UNA_OP --> 
        | '-'
        | not
        | '~'
    
    FUNC_SUB_CALL --> id ( LIST_EXPRESSION )

-------------------------------------------------------------------------------  
- Définition des tokens
-------------------------------------------------------------------------------

    fun --> 'fun'
    is --> 'is'
    end --> 'end'
    var --> 'var'
    const --> 'const'
    enum --> 'enum'
    id --> ($ | + | # | - | @)?[a-zA-Z][a-zA-Z0-9_]*
    true --> 'true'
    false --> 'false'
    integer --> ( [0-9][0-9]* | [0-9][0-9]?[0-9]?( [0-9][0-9][0-9])*
    float --> [0-9][0-9]*.[0-9]*
    string --> "*"
    if --> 'if'
    then --> 'then'
    elseif --> 'elseif'
    else --> 'else'
    while --> 'while'
    do --> 'do'
    repeat --> 'repeat'
    until --> 'until'
    for --> 'for'
    break --> 'break'
    next --> 'next'
    return --> 'return'
    and --> 'and'
    or --> 'or'
    not --> 'not'
    module --> 'module'
    require --> 'require'
    sub --> 'sub'
    
-------------------------------------------------------------------------------  
- Commentaires
-------------------------------------------------------------------------------

1. Un appel de fonction peut se passer de paramètre, mais dans ce cas-là, au niveau du parser, c'est juste un appel à un id. C'est au niveau de l'analyzer qu'il réinterprétera cette id en fonction du contexte déclaré.

2. On peut remplacer les tokens is, then, do et le littéral ';' par un retour à la ligne. On dira que l'analyser "rajoute le token correspondant" pour ne pas surcharger la grammaire.

?. La question de faire AUTO_CLOSE_STATEMENT et OPEN_STATEMENT. Les premiers n'ont pas besoin de ';' à la fin avant de démarrer un nouveau statement. Pour éviter le laid end ; next. Mais en fait...

?. Avec cette grammaire, on peut déjà déclarer des pseudo-classes :

const Personne = {
    age = 5,
    birthday = fun is @age = @age + 1 end,
}
var p = Personne.new() # alias sur clone
p.birthday
writeln(p.age) # 6

?. Ce qu'on peut faire avec les id n'est pas spécifié dans cette grammaire : $id (globale, les const le sont auto), *id (liste de param), &id (hash de param : mais il faut pouvoir appeler avec un nom !), +id -id #id respectivement une clé publique, privée, et protégée.

?. Typage des variables.

?. Gestion des modules !

?. Peut-être pouvoir faire import dans un hash ? pour étendre un précédent hash ?

?. id de fonction avec ? et ! à la fin

?. On testera nil avec == pas is None comme en Python

?. valoriser les enums ? (av 1 type)

?. retirer les enums ?

?. pas de redo / retry

?. dans les dico = au lieu de : (choquant si pas symbole : "a" = 5 non. => ?

?. on peut faire enum et strict avec dico mais c'est pour les passer en type ensuite.

?. Il faudrait fusionner CalcoolettePy et CalcooletteC et CalcooletteJS et Cléa dans un seul modèle.

?. Définir l'interrogation de définition : defined? (en méthode) non car on veut savoir si une var existe, il faut un keyword ??? ou ?

?. Les exceptions : try / catch / finally / throw ou try / except / finally / throw

?. Le switch : switch / case / default / break ou case / when / others / break

?. Le else if : elseif / elsif / elif

?. Les var des for doivent-elles être déclarée avant ?