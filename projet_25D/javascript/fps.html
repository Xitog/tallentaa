<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>FPS 2.5D</title>
    <style type="text/css">
      canvas { 
        border: 1px solid black;
      }
      html {
        width: 100%;
        height: 100%;
        background: rgb(10, 10, 10);
        overflow:hidden;
      }
      body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      img.shadow {
        display: none;
      }
    </style>
  </head>
  <body onload="start();">
    <canvas id="screen" width="960" height="800">Your browser must support canvas to play.</canvas>
    <!--<img class="shadow" id="black" src="graphics/black.png">-->
    
    <script type="text/javascript">
    
      // 20 => 640 25 => 800 30 => 960
      const ZOOM = 100;
      
      const SCREEN_WIDTH = 960;
      const SCREEN_HEIGHT = 800;
      
      const CAM_MAX_COL = SCREEN_WIDTH / ZOOM; // 30
      const CAM_MAX_ROW = SCREEN_HEIGHT / ZOOM; // 25
      
      var screen = null;
      var mouse_col = -1;
      var mouse_row = -1;
      var show_number = true;
      
      const KEY_UP = 38;
      const KEY_DOWN = 40;
      const KEY_RIGHT = 39;
      const KEY_LEFT = 37;
      const KEY_BACKSPACE = 8;
      const KEY_M = 77;
      const KEY_TAB = 9;
      
      var keys_down = {
        38 : false,
        40 : false,
        37 : false,
        39 : false
      };
      
      const NONE = 0;
      const VERTICAL = 1;
      const HORIZONTAL = 2;
      const MIN_SIZE = 5;
      const MAX_DIVISION = 4;
      
      const EMPTY_TEXTURE = 0;
      const PLAIN_TEXTURE = 1;
      const MIN_TEXTURE = 2;
      
      const ROTATION_MOD = 0.1;
      const MOVEMENT_MOD = 0.2;
      
      const HITBOX = 0.90; // 1.42
      
      var units = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ];
      
      var map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      ];
      
      var textures = [];
      var color_index = 1;
      
      function get_color() {
        let res = color_index;
        color_index += 1;
        if (color_index == textures.length) {
          color_index = MIN_TEXTURE;
        }
        //console.log("color = " + res + " / " + textures.length);
        return res;
      }
      
      const EMPTY = 0;
      var ROOM_ID = 1;
      var ROOMS = {};
      
      class Thing {
        constructor(type, x, y) {
          this.type = type;
          this.x = x;
          this.y = y;
        }
      }
      
      class MedPack extends Thing {
      
        constructor(x, y) {
          super('medpack', x, y);
        }
        
        action(game) {
          game.player.life = Math.min(100, game.player.life + 10);
        }
        
        draw(ctx, x, y) {
          ctx.fillStyle = 'white';
          ctx.fillRect(x - 10, y - 10, 20, 20);
          ctx.fillStyle = 'red';
          ctx.fillRect(x - 2, y - 5, 4, 10);
          ctx.fillRect(x - 5, y - 2, 10, 4);
        }
      }
         
      class Entity {
        constructor(type, x, y, angle) {
          this.type = type;
          this.x = x;
          this.y = y;
          this.angle = angle;
          units[Math.floor(this.y)][Math.floor(this.x)] = 1;
        }
      }

      class Player {
        constructor(x, y, angle, life) {
          this.x = x;
          this.y = y;
          this.set_angle(angle);
          this.life = life;
        }
        
        set_angle(angle) {
          this.angle = angle;
          this.dir_x = Math.cos(this.angle);
          this.dir_y = -Math.sin(this.angle);
          this.camera_plane_x = Math.cos(this.angle + Math.PI / 2);
          this.camera_plane_y = -Math.sin(this.angle + Math.PI / 2);
          // Dans la représentation mathématique
          // les positifs sont vers le haut :
          // il faut donc inverser !
          this.set_box();
        }
        
        set_box() {
          this.box_max_x = this.x + HITBOX;
          this.box_min_x = this.x - HITBOX;
          this.box_max_y = this.y + HITBOX;
          this.box_min_y = this.y - HITBOX;
          this.box_width = HITBOX * 2;
          this.box_height = HITBOX * 2;
          return;
          this.box_max_x = Math.max(Math.max(this.x, this.x + this.dir_x + this.camera_plane_x), this.x + this.dir_x - this.camera_plane_x);
          this.box_max_y = Math.max(Math.max(this.y, this.y + this.dir_y + this.camera_plane_y), this.y + this.dir_y - this.camera_plane_y);
          this.box_min_x = Math.min(Math.min(this.x, this.x + this.dir_x + this.camera_plane_x), this.x + this.dir_x - this.camera_plane_x);
          this.box_min_y = Math.min(Math.min(this.y, this.y + this.dir_y + this.camera_plane_y), this.y + this.dir_y - this.camera_plane_y);
          this.box_width = this.box_max_x - this.box_min_x;
          this.box_height = this.box_max_y - this.box_min_y;
        }
        
        mod_angle(mod) {
          let old_angle = this.angle;
          this.set_angle(this.angle + mod);
          this.set_box();
          
          let ok = this.check();
          
          if (!ok) {
            this.set_angle(old_angle);
            this.set_box();
          }
        }
        
        check() {
          let start_x = Math.floor(this.box_min_x);
          let start_y = Math.floor(this.box_min_y);
          let end_x = Math.floor(this.box_max_x);
          let end_y = Math.floor(this.box_max_y);
          let ok = true;
          console.log(start_x, start_y, end_x, end_y);
          outer_loop : for (let row = start_y; row <= end_y; row++) {
            for (let col = start_x; col <= end_x; col++) {
              console.log('x=', col, 'y=', row);
              if (map[row][col] != 0 || units[row][col] != 0) {
                ok = false;
                break outer_loop;
              }
            }
          }
          return ok;
        }
        
        mod_position(mod) {
          let old_x = this.x;
          let old_y = this.y;
          
          let new_x = this.x + this.dir_x * mod;
          let new_y = this.y + this.dir_y * mod;
          
          this.x = new_x;
          this.y = new_y;
          this.set_box();
          
          let ok = this.check();
          
          if (!ok) {
            this.x = old_x;
            this.set_box();
            ok = this.check();
            if (!ok) {
              this.x = new_x;
              this.y = old_y;
              this.set_box();
              ok = this.check();
              if (!ok) {
                this.x = old_x;
                this.y = old_y;
                this.set_box();
              }
            }
          }
        }
      }
      
      class Game {
        constructor() {
          this.player = new Player(5.0, 5.5, Math.PI / 2, 100);
          this.entities = [];
          this.entities.push(new Entity('soldier', 2.5, 2.5, Math.PI / 2));
          this.things = [];
          this.things.push(new MedPack(1.5, 3.5));
        }
      }
      
      function load() {
        for (let o of document.images) {
          textures.push(o);
          //textures[o.id] = o;
        }
        console.log("End loading " + textures.length + " textures.");
      }
      
      var game;
      
      function start() {
        screen = document.getElementById('screen');
        screen.onmousemove = on_mouse_move;
        window.onclick = on_mouse_left_click;
        window.oncontextmenu = on_mouse_right_click;
        window.onkeydown = on_key_down;
        window.onkeyup = on_key_up;
        window.setInterval(run, 33);
        console.log(screen.getContext('2d').globalCompositeOperation);
        //screen.getContext('2d').globalCompositeOperation = 'copy';
        load();
        game = new Game();
        run();
      }
      
      function run() {
        update();
        draw();
      }
      
      function update() {
        if (keys_down[KEY_LEFT]) {
          game.player.mod_angle(ROTATION_MOD);
        }
        if (keys_down[KEY_RIGHT]) {
          game.player.mod_angle(-ROTATION_MOD);
        }
        if (keys_down[KEY_UP]) {
          game.player.mod_position(MOVEMENT_MOD);
        }
        if (keys_down[KEY_DOWN]) {
          game.player.mod_position(-MOVEMENT_MOD);
        }
        let things2 = []
        for (let obj of game.things) {
          if (Math.floor(obj.x) == Math.floor(game.player.x) && 
              Math.floor(obj.y) == Math.floor(game.player.y)) {
              obj.action(game);
          } else {
              things2.push(obj);
          }
        }
        game.things = things2;
      }
      
      function draw() {
        if (screen.getContext) {
          let ctx = screen.getContext('2d');
          ctx.clearRect(0, 0, screen.width, screen.height);
          ctx.font = "10px Arial";
          ctx.fillStyle = "black";
          for (let row = 0; row < CAM_MAX_ROW && row < map.length; row++) {
            for (let col = 0; col < CAM_MAX_COL && col < map[row].length; col++) {
              let index = map[row][col];
              if (index == 0) {
                let unit = units[row][col];
                if (unit == 0) {
                  ctx.fillStyle = 'rgb(0, 0, 0)';
                  ctx.fillRect(col * ZOOM, row * ZOOM, ZOOM, ZOOM);
                } else {
                  ctx.fillStyle = 'rgb(255, 0, 0)';
                  ctx.fillRect(col * ZOOM, row * ZOOM, ZOOM, ZOOM);
                }
                ctx.strokeStyle = 'rgb(120, 120, 120)';
                ctx.beginPath();
                ctx.rect(col * ZOOM, row * ZOOM, ZOOM, ZOOM);
                ctx.stroke();
                if (show_number) {
                  ctx.fillStyle = 'rgb(255, 255, 255)';
                  ctx.fillText(col + ":" + row, col * ZOOM + 10, row * ZOOM + 10); 
                }
              } else {
                ctx.fillStyle = 'rgb(60, 60, 60)';
                ctx.fillRect(col * ZOOM, row * ZOOM, ZOOM, ZOOM);
              }
            }
          }
          
          let px = game.player.x * ZOOM;
          let py = game.player.y * ZOOM;
          let dx = px + game.player.dir_x * ZOOM;
          let dy = py + game.player.dir_y * ZOOM;
          let cx = dx + game.player.camera_plane_x * ZOOM;
          let cy = dy + game.player.camera_plane_y * ZOOM;
          let c2x = dx - game.player.camera_plane_x * ZOOM;
          let c2y = dy - game.player.camera_plane_y * ZOOM;
          
          ctx.strokeStyle = 'yellow';
          ctx.beginPath();
          ctx.rect(px - 1, py - 1, 3, 3);
          ctx.moveTo(px, py);
          ctx.lineTo(dx, dy);
          ctx.stroke();
          
          ctx.strokeStyle = 'red';
          ctx.beginPath();
          ctx.moveTo(dx, dy);
          ctx.lineTo(cx, cy);
          ctx.lineTo(px, py);
          ctx.lineTo(c2x, c2y);
          ctx.lineTo(dx, dy);
          ctx.stroke();
          
          ctx.strokeStyle = 'green';
          ctx.beginPath();
          let max_x = Math.max(Math.max(c2x, cx), px);
          let max_y = Math.max(Math.max(c2y, cy), py);
          let min_x = Math.min(Math.min(c2x, cx), px);
          let min_y = Math.min(Math.min(c2y, cy), py);
          ctx.rect(game.player.box_min_x * ZOOM, game.player.box_min_y * ZOOM, 
                   game.player.box_width * ZOOM, game.player.box_height * ZOOM);
          ctx.stroke();
          
          ctx.strokeStyle = 'rgb(0, 255, 0)';
          ctx.strokeRect(Math.floor(mouse_col / ZOOM) * ZOOM, Math.floor(mouse_row / ZOOM) * ZOOM, ZOOM, ZOOM);
          
          //ctx.beginPath();
          //ctx.rect(px - 142, py - 142, 284, 284);
          //ctx.stroke();
          
          ctx.strokeStyle = 'white';
          for (let ent of game.entities) {
            ctx.beginPath();
            ctx.arc(ent.x * ZOOM, ent.y * ZOOM, 30, 0, 2 * Math.PI);
            ctx.stroke(); //ctx.fill();
          }
          for (let obj of game.things) {
            let objx = obj.x * ZOOM;
            let objy = obj.y * ZOOM;
            obj.draw(ctx, objx, objy);
          }
        }
      }
      
      function on_mouse_move(event) {
        event = event || window.event;
        // Mouse coordinates
        let screenRect = screen.getBoundingClientRect();
        mouse_col = event.pageX - screenRect.left;
        mouse_row = event.pageY - screenRect.top;
        //mouse_map_col = Math.floor(mouse_col / 32) + camera.col;
        //mouse_map_row = Math.floor(mouse_row / 32) + camera.row;
      }
      
      function on_mouse_left_click(event) {
        event = event || window.event;
        console.log('Mouse col:', Math.floor(mouse_col / 32), 'Mouse row:', Math.floor(mouse_row / 32));
      }
      
      function on_mouse_right_click(event) {
        event = event || window.event;
        console.log('Mouse col:', mouse_col, 'Mouse row:', mouse_row);
        return false;     // prevent default menu
      }
      
      function on_key_up(event) {
        event = window.event || event;
        if (event.keyCode in keys_down) {
          keys_down[event.keyCode] = false;
        } else if (event.keyCode == KEY_M) {
          show_number = ! show_number;
        } else {
          console.log('Unbound up key:', event.keyCode);
        }
      }
      
      function on_key_down(event){
        event = window.event || event;
        if (event.keyCode in keys_down) {
          keys_down[event.keyCode] = true;
        } else {
          console.log('Unbound down key:', event.keyCode);
        }
      }
      
    </script>
  </body>
</html>